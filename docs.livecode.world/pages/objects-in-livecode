{
  "title": "Objects in Livecode",
  "story": [
    {
      "type": "paragraph",
      "id": "68b55a8a7e0c73fd",
      "text": "An object (regardless of what language it is rendered in, or with whatever specific kind of 'oop' methodology you care to subscribe to) is simply some state (i.e. variables which are distinct for each instance of the object) with an associated list of handlers/methods/functions which act on that state. "
    },
    {
      "type": "paragraph",
      "id": "19d9e3d08b431756",
      "text": "You should also require that the state is entirely hidden and encapsulated within the object and not visible from the outside world - although most OOP languages do this very very poorly."
    },
    {
      "type": "html",
      "id": "bce26f4394dfa608",
      "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been.\n\n<li> LiveCode is definitely object-oriented:\n   <ul>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script.\n   </ul>\n\n<li> LiveCode Script is designed to allow this rapid gluing and adaptation, and as such has a loose stringy type-system and dynamic message path to aid this rapidity.\n\n<li> LiveCode Builder could become less strict in the future as an option, to make it easier for people who are familiar with Script to write Builder to build widgets.\n\n<li> LiveCode Script is probably not the thing to use to write widgets, but the ability to be able to package up a group of controls as a black-box just like a widget would be entirely consistent and self-similar with the existing environment.\n</ol>"
    },
    {
      "type": "paragraph",
      "id": "cb1e07afbb39d0cd",
      "text": "In LiveCode, this is perhaps slightly hidden behind the English-like syntactic sugar. For example, one can imagine that:"
    },
    {
      "type": "code",
      "id": "b49921a34e56ed19",
      "text": "get the fooBar of myObject"
    },
    {
      "type": "paragraph",
      "id": "d4daf6d3eb816746",
      "text": "Is the same as (in a non English-like language):"
    },
    {
      "type": "code",
      "id": "c7ecab33a49fecfd",
      "text": "it := myObject.GetFooBar()\n"
    },
    {
      "type": "paragraph",
      "id": "f0e2b31e5c5f466d",
      "text": "Or something like:"
    },
    {
      "type": "code",
      "id": "10d841f02b87e951",
      "text": "copy myObject"
    },
    {
      "type": "paragraph",
      "id": "a2467a7d16dc9f52",
      "text": "\n"
    },
    {
      "type": "paragraph",
      "id": "d4017c66c3966aad",
      "text": "Is the same as (again, in a non English-like language):\n\n"
    },
    {
      "type": "code",
      "id": "f8c6fb736cd1ef54",
      "text": "myObject.Copy()"
    },
    {
      "type": "paragraph",
      "id": "5b3a074b2ce29b8b",
      "text": "\n"
    },
    {
      "type": "paragraph",
      "id": "10dac03dfa913de4",
      "text": "Therefore, I have absolutely no hesitation in saying that LiveCode is object-oriented (for some definition of object-oriented). Indeed, it always has been - everyone who has ever programming in an xTalk had been doing object-oriented programming since it started to become 'popular' ([[HyperCard]] appeared in 1987, [[Cfront]] - the original C++ - appeared in 1985 - although the first 'object oriented' languages such as [[Simula]] appeared perhaps a decade before)."
    },
    {
      "type": "paragraph",
      "id": "f3c4c4cd7b490e63",
      "text": "The reason why I tend to hesitate saying LiveCode is object-oriented explicitly (well, up until 8, at least) is that the kind of way you do programming in LiveCode is perhaps not quite the same as what people expect when they hear that 'a language is object oriented'. The LiveCode model is essentially that of aggregation and adaptation, rather than inheritance (people tend to be highly aware of the later, but not aware of the former even though they will be implicitly doing it day-in-day-out in any programming language they are a practitioner of)."
    },
    {
      "type": "paragraph",
      "id": "94fe7bf078e7fcce",
      "text": "In LiveCode, you build applications by using the building-blocks you drag from the control palette to build more complicated things (aggregation), and then you apply scripts to each object to change the behavior of the building-blocks appropriate to your app (adaptation)."
    },
    {
      "type": "paragraph",
      "id": "997f3d246d514873",
      "text": "Now, inheritance is orthogonal to the idea of aggregation and adaptation - and it should be noted that most 'traditional' OOP languages allow you to do inheritance, but you have to build the framework to do aggregation and adaptation yourself (hence why Java, Obj-C, C++ etc. all have a large variety of 'frameworks' you can leverage to actually build apps - if you tried to do so with the 'raw' language, you'll find yourself just reinventing some sort of structure which is probably not too dissimilar to LiveCode's)."
    },
    {
      "type": "paragraph",
      "id": "58ebefebf6b31871",
      "text": "When we added 'behaviors' you could argue that 'inheritance' did actually start to creep in - behaviors allow you to factor out the code which you use to adapt the building blocks (i.e. your scripts) into an informal hierarchy. (Informal here refers to the fact you don't need to make type definitions - which is entirely appropriate to LiveCode which tends not to force that kind of thing on you anywhere - except in Builder, and only then if you really want to)."
    },
    {
      "type": "paragraph",
      "id": "195d07249b7c95de",
      "text": "With 8, however, you can start to see the 'class inheritance' ability being added to LiveCode - that is what widgets are. i.e. You can write your own building blocks (in LiveCode Builder). (For those of you who have looked at Builder, then although it is not yet explicit - a module is essentially a class - a widget is a module which can have multiple instances and a library is a module which only ever has a single instance)."
    },
    {
      "type": "paragraph",
      "id": "0091253a229e9eed",
      "text": "So, right now in LiveCode, the objects you have to play with are stacks, cards, audioclips, videoclips, fields, buttons, scrollbars, players, images, buttons, groups, graphics and widgets. However, remember that 'widgets' are a completely extensible set of things, so this list is no longer fixed as it was before."
    },
    {
      "type": "paragraph",
      "id": "2c84376fc29de98c",
      "text": "To go back to the original point about controls vs objects then this is actually very well defined (indeed, it is embodied in the source of the engine - i.e. how LiveCode is actually implemented). A control is an object which sits on a card or in a group."
    },
    {
      "type": "paragraph",
      "id": "782e9e93680507d3",
      "text": "Indeed, you have the following 'inheritance' hierarchy:\n\n    Object\n       Stack\n       Card\n       AudioClip\n       VideoClip\n       Control\n         Group\n         Field\n         Button\n         Scrollbar\n         Player\n         Image\n         Button\n         Graphic\n         Widget\n           <all widgets>\n\nThis means that a stack is an object, but not a control. A player is a control, and therefore an object. AudioClips and VideoClips aren't really 'controls' in this sense because they sit on a stack , and not a card (although the Import Menu does call them so - which is perhaps the reason for the slight amount of confusion).\n\nAt runtime, objects in LiveCode form themselves into a tree (note this tree is about *ownership* of instances of objects, not inheritance):\n\n    Stack\n      Substack\n        <same as stack>\n      AudioClips\n      Videoclips\n      Cards\n        Controls\n        Groups\n          Controls\n\nYou use LiveCode Script to attach 'adaptations' to your objects, and the message path allows a simple way for these adaptations to communicate.\n\nAs LiveCode Script does not have 'strong references to objects' (and cannot have them unless we want to lose stringyness entirely - which is actually one of the main differences between Script and Builder) you create named objects in this hierarchy and then manipulate them using chunk expressions - i.e. references are strings describing a path in the object tree such as 'button \"Foo\" of card \"Bar\" of stack \"Baz\".\n\nAnother way to think about this is that, in LiveCode Script, every object must have an explicit name. You use chunk expressions to select an object based on various criteria (type, owner). Once created, objects exist in the tree until they are explicitly deleted.\n\nIndeed, one of the reasons 'OOP as you see it in other languages' is very unlikely to appear in LiveCode Script is because there is no way to represent a reference to a temporary object which disappears when there are no references to it. As all references must be strings, and strings can sit in arbitrary other strings, there is no way for the engine to ever know when you don't need an object anymore - you have to tell it. I don't really see this as a limitation, however, because that is the object model of LiveCode Script - you adapt named instances of building blocks with your scripts!\n\nOf course, it would be nice if you could write widgets in 'LiveCode Script' - however, I'm not sure it is entirely appropriate. The stringy type system which Script has compared to Builder means that some things you really need to be able to do to write widgets in the way Builder does become quite tortuous. That being said, there is room for 'Builder' to come closer to 'Script' in terms of its strictness - at least as an option - i.e. Script without the 'everything is a string' concept.\n\nPerhaps the thing which is much more important at the Script level is the ability to take a collection of LiveCode objects and scripts etc. and wrap them up with an 'inner script' which presents them as a single black-box control - just like a widget. This is the idea of 'template objects', or custom controls 'done properly' (for some definition of properly, of course). This is a recursive application of the ideas which you are already familiar with when you build your apps and has a very nice 'self-similarity' and symmetry (\"It's turtles all the way down\").\n\n"
    },
    {
      "type": "markdown",
      "id": "0143cc98c7b3daf2",
      "text": "# Summary"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Objects in Livecode",
        "story": []
      },
      "date": 1466509570735
    },
    {
      "item": {
        "type": "factory",
        "id": "68b55a8a7e0c73fd"
      },
      "id": "68b55a8a7e0c73fd",
      "type": "add",
      "date": 1466509572298
    },
    {
      "type": "edit",
      "id": "68b55a8a7e0c73fd",
      "item": {
        "type": "paragraph",
        "id": "68b55a8a7e0c73fd",
        "text": "An object (regardless of what language it is rendered in, or with whatever specific kind of 'oop' methodology you care to subscribe to) is simply some state (i.e. variables which are distinct for each instance of the object) with an associated list of handlers/methods/functions which act on that state. (Indeed, really I think one should require that the state is entirely hidden and encapsulated within the object and not visible from the outside world - although most OOP languages do this very very poorly).\n\nIn LiveCode, this is perhaps slightly hidden behind the English-like syntactic sugar. For example, one can imagine that:\n\n   get the fooBar of myObject\n\nIs the same as (in a non English-like language):\n\n   it := myObject.GetFooBar()\n\nOr something like:\n\n   copy myObject\n\nIs the same as (again, in a non English-like language):\n\n   myObject.Copy()\n\nTherefore, I have absolutely no hesitation in saying that LiveCode is object-oriented (for some definition of object-oriented). Indeed, it always has been - everyone who has ever programming in an xTalk had been doing object-oriented programming since it started to become 'popular' (HyperCard appeared in 1987, Cfront - the original C++ - appeared in 1985 - although the first 'object oriented' languages such as Simula appeared perhaps a decade before).\n\nThe reason why I tend to hesitate saying LiveCode is object-oriented explicitly (well, up until 8, at least) is that the kind of way you do programming in LiveCode is perhaps not quite the same as what people expect when they hear that 'a language is object oriented'. The LiveCode model is essentially that of aggregation and adaptation, rather than inheritance (people tend to be highly aware of the later, but not aware of the former even though they will be implicitly doing it day-in-day-out in any programming language they are a practitioner of).\n\nIn LiveCode, you build applications by using the building-blocks you drag from the control palette to build more complicated things (aggregation), and then you apply scripts to each object to change the behavior of the building-blocks appropriate to your app (adaptation).\n\nNow, inheritance is orthogonal to the idea of aggregation and adaptation - and it should be noted that most 'traditional' OOP languages allow you to do inheritance, but you have to build the framework to do aggregation and adaptation yourself (hence why Java, Obj-C, C++ etc. all have a large variety of 'frameworks' you can leverage to actually build apps - if you tried to do so with the 'raw' language, you'll find yourself just reinventing some sort of structure which is probably not too dissimilar to LiveCode's).\n\nWhen we added 'behaviors' you could argue that 'inheritance' did actually start to creep in - behaviors allow you to factor out the code which you use to adapt the building blocks (i.e. your scripts) into an informal hierarchy. (Informal here refers to the fact you don't need to make type definitions - which is entirely appropriate to LiveCode which tends not to force that kind of thing on you anywhere - except in Builder, and only then if you really want to).\n\nWith 8, however, you can start to see the 'class inheritance' ability being added to LiveCode - that is what widgets are. i.e. You can write your own building blocks (in LiveCode Builder). (For those of you who have looked at Builder, then although it is not yet explicit - a module is essentially a class - a widget is a module which can have multiple instances and a library is a module which only ever has a single instance).\n\nSo, right now in LiveCode, the objects you have to play with are stacks, cards, audioclips, videoclips, fields, buttons, scrollbars, players, images, buttons, groups, graphics and widgets. However, remember that 'widgets' are a completely extensible set of things, so this list is no longer fixed as it was before.\n\nTo go back to the original point about controls vs objects then this is actually very well defined (indeed, it is embodied in the source of the engine - i.e. how LiveCode is actually implemented). A control is an object which sits on a card or in a group.\n\nIndeed, you have the following 'inheritance' hierarchy:\n\n    Object\n       Stack\n       Card\n       AudioClip\n       VideoClip\n       Control\n         Group\n         Field\n         Button\n         Scrollbar\n         Player\n         Image\n         Button\n         Graphic\n         Widget\n           <all widgets>\n\nThis means that a stack is an object, but not a control. A player is a control, and therefore an object. AudioClips and VideoClips aren't really 'controls' in this sense because they sit on a stack , and not a card (although the Import Menu does call them so - which is perhaps the reason for the slight amount of confusion).\n\nAt runtime, objects in LiveCode form themselves into a tree (note this tree is about *ownership* of instances of objects, not inheritance):\n\n    Stack\n      Substack\n        <same as stack>\n      AudioClips\n      Videoclips\n      Cards\n        Controls\n        Groups\n          Controls\n\nYou use LiveCode Script to attach 'adaptations' to your objects, and the message path allows a simple way for these adaptations to communicate.\n\nAs LiveCode Script does not have 'strong references to objects' (and cannot have them unless we want to lose stringyness entirely - which is actually one of the main differences between Script and Builder) you create named objects in this hierarchy and then manipulate them using chunk expressions - i.e. references are strings describing a path in the object tree such as 'button \"Foo\" of card \"Bar\" of stack \"Baz\".\n\nAnother way to think about this is that, in LiveCode Script, every object must have an explicit name. You use chunk expressions to select an object based on various criteria (type, owner). Once created, objects exist in the tree until they are explicitly deleted.\n\nIndeed, one of the reasons 'OOP as you see it in other languages' is very unlikely to appear in LiveCode Script is because there is no way to represent a reference to a temporary object which disappears when there are no references to it. As all references must be strings, and strings can sit in arbitrary other strings, there is no way for the engine to ever know when you don't need an object anymore - you have to tell it. I don't really see this as a limitation, however, because that is the object model of LiveCode Script - you adapt named instances of building blocks with your scripts!\n\nOf course, it would be nice if you could write widgets in 'LiveCode Script' - however, I'm not sure it is entirely appropriate. The stringy type system which Script has compared to Builder means that some things you really need to be able to do to write widgets in the way Builder does become quite tortuous. That being said, there is room for 'Builder' to come closer to 'Script' in terms of its strictness - at least as an option - i.e. Script without the 'everything is a string' concept.\n\nPerhaps the thing which is much more important at the Script level is the ability to take a collection of LiveCode objects and scripts etc. and wrap them up with an 'inner script' which presents them as a single black-box control - just like a widget. This is the idea of 'template objects', or custom controls 'done properly' (for some definition of properly, of course). This is a recursive application of the ideas which you are already familiar with when you build your apps and has a very nice 'self-similarity' and symmetry (\"It's turtles all the way down\").\n\n"
      },
      "date": 1466509583884
    },
    {
      "type": "add",
      "id": "0143cc98c7b3daf2",
      "item": {
        "type": "paragraph",
        "id": "0143cc98c7b3daf2",
        "text": "# Summary"
      },
      "after": "68b55a8a7e0c73fd",
      "date": 1466509588446
    },
    {
      "type": "add",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "paragraph",
        "id": "bce26f4394dfa608",
        "text": "1) Objects and Controls are very well defined concepts in LiveCode and always have been. There might be some places in the docs and IDE, however, where it uses the wrong term and I that should be corrected (i.e. if you notice an instance of this file a report, and we'll look into correcting it)."
      },
      "after": "0143cc98c7b3daf2",
      "date": 1466509604992
    },
    {
      "type": "add",
      "id": "856e704e17f03b78",
      "item": {
        "type": "paragraph",
        "id": "856e704e17f03b78",
        "text": "2) LiveCode is definitely object-oriented:\n\n      i) You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      ii) You aggregate black-box objects together then adapt and glue them together using LiveCode Script.\n\n"
      },
      "after": "bce26f4394dfa608",
      "date": 1466509613708
    },
    {
      "type": "add",
      "id": "d618655da4a5d821",
      "item": {
        "type": "paragraph",
        "id": "d618655da4a5d821",
        "text": "3) LiveCode Script is designed to allow this rapid gluing and adaptation, and as such has a loose stringy type-system and dynamic message path to aid this rapidity.\n\n"
      },
      "after": "856e704e17f03b78",
      "date": 1466509618032
    },
    {
      "type": "add",
      "id": "180900f4b3975c38",
      "item": {
        "type": "paragraph",
        "id": "180900f4b3975c38",
        "text": "4) LiveCode Builder could become less strict in the future as an option, to make it easier for people who are familiar with Script to write Builder to build widgets.\n\n"
      },
      "after": "d618655da4a5d821",
      "date": 1466509620808
    },
    {
      "type": "add",
      "id": "f66f4ae179d2efb8",
      "item": {
        "type": "paragraph",
        "id": "f66f4ae179d2efb8",
        "text": "5) LiveCode Script is probably not the thing to use to write widgets, but the ability to be able to package up a group of controls as a black-box just like a widget would be entirely consistent and self-similar with the existing environment."
      },
      "after": "180900f4b3975c38",
      "date": 1466509622914
    },
    {
      "type": "edit",
      "id": "0143cc98c7b3daf2",
      "item": {
        "type": "markdown",
        "id": "0143cc98c7b3daf2",
        "text": "# Summary"
      },
      "date": 1466509624588
    },
    {
      "type": "edit",
      "id": "856e704e17f03b78",
      "item": {
        "type": "paragraph",
        "id": "856e704e17f03b78",
        "text": "2) LiveCode is definitely object-oriented:\n\n      i) You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      ii) You aggregate black-box objects together then adapt and glue them together using LiveCode Script."
      },
      "date": 1466509649146
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "paragraph",
        "id": "bce26f4394dfa608",
        "text": "<ol><li>Objects and Controls are very well defined concepts in LiveCode and always have been. There might be some places in the docs and IDE, however, where it uses the wrong term and I that should be corrected (i.e. if you notice an instance of this file a report, and we'll look into correcting it)."
      },
      "date": 1466509686596
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol><li>Objects and Controls are very well defined concepts in LiveCode and always have been. There might be some places in the docs and IDE, however, where it uses the wrong term and I that should be corrected (i.e. if you notice an instance of this file a report, and we'll look into correcting it)."
      },
      "date": 1466509687388
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been. There might be some places in the docs and IDE, however, where it uses the wrong term and I that should be corrected (i.e. if you notice an instance of this file a report, and we'll look into correcting it)."
      },
      "date": 1466509698087
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been. There might be some places in the docs and IDE, however, where it uses the wrong term and I that should be corrected (i.e. if you notice an instance of this file a report, and we'll look into correcting it).\n\n<li> 2) LiveCode is definitely object-oriented:\n   <ol>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script."
      },
      "date": 1466509759719
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been. There might be some places in the docs and IDE, however, where it uses the wrong term and I that should be corrected (i.e. if you notice an instance of this file a report, and we'll look into correcting it).\n\n<li> LiveCode is definitely object-oriented:\n   <ol>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script."
      },
      "date": 1466509768304
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been.\n\n<li> LiveCode is definitely object-oriented:\n   <ol>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script."
      },
      "date": 1466509793092
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been.\n\n<li> LiveCode is definitely object-oriented:\n   <ul>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script.\n   </ul>\n\n<li> LiveCode Script is designed to allow this rapid gluing and adaptation, and as such has a loose stringy type-system and dynamic message path to aid this rapidity.\n"
      },
      "date": 1466509853042
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been.\n\n<li> LiveCode is definitely object-oriented:\n   <ul>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script.\n   </ul>\n\n<li> LiveCode Script is designed to allow this rapid gluing and adaptation, and as such has a loose stringy type-system and dynamic message path to aid this rapidity.\n\n<li> LiveCode Builder could become less strict in the future as an option, to make it easier for people who are familiar with Script to write Builder to build widgets.\n"
      },
      "date": 1466509870195
    },
    {
      "type": "edit",
      "id": "bce26f4394dfa608",
      "item": {
        "type": "html",
        "id": "bce26f4394dfa608",
        "text": "<ol>\n<li> Objects and Controls are very well defined concepts in LiveCode and always have been.\n\n<li> LiveCode is definitely object-oriented:\n   <ul>\n      <li> You build black-box objects in LiveCode Builder (which is, although not explicitly yet exposed, class-based).\n\n      <li> You aggregate black-box objects together then adapt and glue them together using LiveCode Script.\n   </ul>\n\n<li> LiveCode Script is designed to allow this rapid gluing and adaptation, and as such has a loose stringy type-system and dynamic message path to aid this rapidity.\n\n<li> LiveCode Builder could become less strict in the future as an option, to make it easier for people who are familiar with Script to write Builder to build widgets.\n\n<li> LiveCode Script is probably not the thing to use to write widgets, but the ability to be able to package up a group of controls as a black-box just like a widget would be entirely consistent and self-similar with the existing environment.\n</ol>"
      },
      "date": 1466509893443
    },
    {
      "type": "remove",
      "id": "856e704e17f03b78",
      "date": 1466509901899
    },
    {
      "type": "remove",
      "id": "d618655da4a5d821",
      "date": 1466509906756
    },
    {
      "type": "remove",
      "id": "180900f4b3975c38",
      "date": 1466509909099
    },
    {
      "type": "remove",
      "id": "f66f4ae179d2efb8",
      "date": 1466509911179
    },
    {
      "type": "move",
      "order": [
        "68b55a8a7e0c73fd",
        "bce26f4394dfa608",
        "0143cc98c7b3daf2"
      ],
      "id": "bce26f4394dfa608",
      "date": 1466509924054
    },
    {
      "type": "edit",
      "id": "68b55a8a7e0c73fd",
      "item": {
        "type": "paragraph",
        "id": "68b55a8a7e0c73fd",
        "text": "An object (regardless of what language it is rendered in, or with whatever specific kind of 'oop' methodology you care to subscribe to) is simply some state (i.e. variables which are distinct for each instance of the object) with an associated list of handlers/methods/functions which act on that state. (Indeed, really I think one should require that the state is entirely hidden and encapsulated within the object and not visible from the outside world - although most OOP languages do this very very poorly)."
      },
      "date": 1466509936054
    },
    {
      "type": "add",
      "id": "cb1e07afbb39d0cd",
      "item": {
        "type": "paragraph",
        "id": "cb1e07afbb39d0cd",
        "text": "In LiveCode, this is perhaps slightly hidden behind the English-like syntactic sugar. For example, one can imagine that:\n\n   get the fooBar of myObject\n\nIs the same as (in a non English-like language):\n\n   it := myObject.GetFooBar()\n\nOr something like:\n\n   copy myObject\n\nIs the same as (again, in a non English-like language):\n\n   myObject.Copy()\n\n"
      },
      "after": "68b55a8a7e0c73fd",
      "date": 1466509944326
    },
    {
      "type": "add",
      "id": "10dac03dfa913de4",
      "item": {
        "type": "paragraph",
        "id": "10dac03dfa913de4",
        "text": "Therefore, I have absolutely no hesitation in saying that LiveCode is object-oriented (for some definition of object-oriented). Indeed, it always has been - everyone who has ever programming in an xTalk had been doing object-oriented programming since it started to become 'popular' (HyperCard appeared in 1987, Cfront - the original C++ - appeared in 1985 - although the first 'object oriented' languages such as Simula appeared perhaps a decade before)."
      },
      "after": "cb1e07afbb39d0cd",
      "date": 1466509949341
    },
    {
      "type": "add",
      "id": "f3c4c4cd7b490e63",
      "item": {
        "type": "paragraph",
        "id": "f3c4c4cd7b490e63",
        "text": "The reason why I tend to hesitate saying LiveCode is object-oriented explicitly (well, up until 8, at least) is that the kind of way you do programming in LiveCode is perhaps not quite the same as what people expect when they hear that 'a language is object oriented'. The LiveCode model is essentially that of aggregation and adaptation, rather than inheritance (people tend to be highly aware of the later, but not aware of the former even though they will be implicitly doing it day-in-day-out in any programming language they are a practitioner of)."
      },
      "after": "10dac03dfa913de4",
      "date": 1466509957042
    },
    {
      "type": "add",
      "id": "94fe7bf078e7fcce",
      "item": {
        "type": "paragraph",
        "id": "94fe7bf078e7fcce",
        "text": "In LiveCode, you build applications by using the building-blocks you drag from the control palette to build more complicated things (aggregation), and then you apply scripts to each object to change the behavior of the building-blocks appropriate to your app (adaptation)."
      },
      "after": "f3c4c4cd7b490e63",
      "date": 1466509963037
    },
    {
      "type": "add",
      "id": "997f3d246d514873",
      "item": {
        "type": "paragraph",
        "id": "997f3d246d514873",
        "text": "Now, inheritance is orthogonal to the idea of aggregation and adaptation - and it should be noted that most 'traditional' OOP languages allow you to do inheritance, but you have to build the framework to do aggregation and adaptation yourself (hence why Java, Obj-C, C++ etc. all have a large variety of 'frameworks' you can leverage to actually build apps - if you tried to do so with the 'raw' language, you'll find yourself just reinventing some sort of structure which is probably not too dissimilar to LiveCode's)."
      },
      "after": "94fe7bf078e7fcce",
      "date": 1466509968789
    },
    {
      "type": "add",
      "id": "58ebefebf6b31871",
      "item": {
        "type": "paragraph",
        "id": "58ebefebf6b31871",
        "text": "When we added 'behaviors' you could argue that 'inheritance' did actually start to creep in - behaviors allow you to factor out the code which you use to adapt the building blocks (i.e. your scripts) into an informal hierarchy. (Informal here refers to the fact you don't need to make type definitions - which is entirely appropriate to LiveCode which tends not to force that kind of thing on you anywhere - except in Builder, and only then if you really want to)."
      },
      "after": "997f3d246d514873",
      "date": 1466509976341
    },
    {
      "type": "add",
      "id": "195d07249b7c95de",
      "item": {
        "type": "paragraph",
        "id": "195d07249b7c95de",
        "text": "With 8, however, you can start to see the 'class inheritance' ability being added to LiveCode - that is what widgets are. i.e. You can write your own building blocks (in LiveCode Builder). (For those of you who have looked at Builder, then although it is not yet explicit - a module is essentially a class - a widget is a module which can have multiple instances and a library is a module which only ever has a single instance)."
      },
      "after": "58ebefebf6b31871",
      "date": 1466509982478
    },
    {
      "type": "add",
      "id": "0091253a229e9eed",
      "item": {
        "type": "paragraph",
        "id": "0091253a229e9eed",
        "text": "So, right now in LiveCode, the objects you have to play with are stacks, cards, audioclips, videoclips, fields, buttons, scrollbars, players, images, buttons, groups, graphics and widgets. However, remember that 'widgets' are a completely extensible set of things, so this list is no longer fixed as it was before."
      },
      "after": "195d07249b7c95de",
      "date": 1466509986270
    },
    {
      "type": "add",
      "id": "2c84376fc29de98c",
      "item": {
        "type": "paragraph",
        "id": "2c84376fc29de98c",
        "text": "To go back to the original point about controls vs objects then this is actually very well defined (indeed, it is embodied in the source of the engine - i.e. how LiveCode is actually implemented). A control is an object which sits on a card or in a group."
      },
      "after": "0091253a229e9eed",
      "date": 1466509989702
    },
    {
      "type": "add",
      "id": "782e9e93680507d3",
      "item": {
        "type": "paragraph",
        "id": "782e9e93680507d3",
        "text": "Indeed, you have the following 'inheritance' hierarchy:\n\n    Object\n       Stack\n       Card\n       AudioClip\n       VideoClip\n       Control\n         Group\n         Field\n         Button\n         Scrollbar\n         Player\n         Image\n         Button\n         Graphic\n         Widget\n           <all widgets>\n\nThis means that a stack is an object, but not a control. A player is a control, and therefore an object. AudioClips and VideoClips aren't really 'controls' in this sense because they sit on a stack , and not a card (although the Import Menu does call them so - which is perhaps the reason for the slight amount of confusion).\n\nAt runtime, objects in LiveCode form themselves into a tree (note this tree is about *ownership* of instances of objects, not inheritance):\n\n    Stack\n      Substack\n        <same as stack>\n      AudioClips\n      Videoclips\n      Cards\n        Controls\n        Groups\n          Controls\n\nYou use LiveCode Script to attach 'adaptations' to your objects, and the message path allows a simple way for these adaptations to communicate.\n\nAs LiveCode Script does not have 'strong references to objects' (and cannot have them unless we want to lose stringyness entirely - which is actually one of the main differences between Script and Builder) you create named objects in this hierarchy and then manipulate them using chunk expressions - i.e. references are strings describing a path in the object tree such as 'button \"Foo\" of card \"Bar\" of stack \"Baz\".\n\nAnother way to think about this is that, in LiveCode Script, every object must have an explicit name. You use chunk expressions to select an object based on various criteria (type, owner). Once created, objects exist in the tree until they are explicitly deleted.\n\nIndeed, one of the reasons 'OOP as you see it in other languages' is very unlikely to appear in LiveCode Script is because there is no way to represent a reference to a temporary object which disappears when there are no references to it. As all references must be strings, and strings can sit in arbitrary other strings, there is no way for the engine to ever know when you don't need an object anymore - you have to tell it. I don't really see this as a limitation, however, because that is the object model of LiveCode Script - you adapt named instances of building blocks with your scripts!\n\nOf course, it would be nice if you could write widgets in 'LiveCode Script' - however, I'm not sure it is entirely appropriate. The stringy type system which Script has compared to Builder means that some things you really need to be able to do to write widgets in the way Builder does become quite tortuous. That being said, there is room for 'Builder' to come closer to 'Script' in terms of its strictness - at least as an option - i.e. Script without the 'everything is a string' concept.\n\nPerhaps the thing which is much more important at the Script level is the ability to take a collection of LiveCode objects and scripts etc. and wrap them up with an 'inner script' which presents them as a single black-box control - just like a widget. This is the idea of 'template objects', or custom controls 'done properly' (for some definition of properly, of course). This is a recursive application of the ideas which you are already familiar with when you build your apps and has a very nice 'self-similarity' and symmetry (\"It's turtles all the way down\").\n\n"
      },
      "after": "2c84376fc29de98c",
      "date": 1466509994081
    },
    {
      "type": "move",
      "order": [
        "68b55a8a7e0c73fd",
        "bce26f4394dfa608",
        "cb1e07afbb39d0cd",
        "10dac03dfa913de4",
        "f3c4c4cd7b490e63",
        "94fe7bf078e7fcce",
        "997f3d246d514873",
        "58ebefebf6b31871",
        "195d07249b7c95de",
        "0091253a229e9eed",
        "2c84376fc29de98c",
        "782e9e93680507d3",
        "0143cc98c7b3daf2"
      ],
      "id": "bce26f4394dfa608",
      "date": 1466510011534
    },
    {
      "type": "edit",
      "id": "68b55a8a7e0c73fd",
      "item": {
        "type": "paragraph",
        "id": "68b55a8a7e0c73fd",
        "text": "An object (regardless of what language it is rendered in, or with whatever specific kind of 'oop' methodology you care to subscribe to) is simply some state (i.e. variables which are distinct for each instance of the object) with an associated list of handlers/methods/functions which act on that state. "
      },
      "date": 1466510028624
    },
    {
      "type": "add",
      "id": "19d9e3d08b431756",
      "item": {
        "type": "paragraph",
        "id": "19d9e3d08b431756",
        "text": "You should also require that the state is entirely hidden and encapsulated within the object and not visible from the outside world - although most OOP languages do this very very poorly."
      },
      "after": "68b55a8a7e0c73fd",
      "date": 1466510059578
    },
    {
      "type": "add",
      "item": {
        "type": "factory",
        "id": "b49921a34e56ed19"
      },
      "after": "bce26f4394dfa608",
      "id": "b49921a34e56ed19",
      "date": 1466510084665
    },
    {
      "type": "edit",
      "id": "cb1e07afbb39d0cd",
      "item": {
        "type": "paragraph",
        "id": "cb1e07afbb39d0cd",
        "text": "In LiveCode, this is perhaps slightly hidden behind the English-like syntactic sugar. For example, one can imagine that:"
      },
      "date": 1466510090191
    },
    {
      "type": "add",
      "id": "d4daf6d3eb816746",
      "item": {
        "type": "paragraph",
        "id": "d4daf6d3eb816746",
        "text": "Is the same as (in a non English-like language):\n\n   it := myObject.GetFooBar()\n\nOr something like:\n\n   copy myObject\n\nIs the same as (again, in a non English-like language):\n\n   myObject.Copy()\n\n"
      },
      "after": "cb1e07afbb39d0cd",
      "date": 1466510097265
    },
    {
      "type": "edit",
      "id": "b49921a34e56ed19",
      "item": {
        "type": "code",
        "id": "b49921a34e56ed19",
        "text": "get the fooBar of myObject"
      },
      "date": 1466510103473
    },
    {
      "type": "move",
      "order": [
        "68b55a8a7e0c73fd",
        "19d9e3d08b431756",
        "bce26f4394dfa608",
        "cb1e07afbb39d0cd",
        "b49921a34e56ed19",
        "d4daf6d3eb816746",
        "10dac03dfa913de4",
        "f3c4c4cd7b490e63",
        "94fe7bf078e7fcce",
        "997f3d246d514873",
        "58ebefebf6b31871",
        "195d07249b7c95de",
        "0091253a229e9eed",
        "2c84376fc29de98c",
        "782e9e93680507d3",
        "0143cc98c7b3daf2"
      ],
      "id": "b49921a34e56ed19",
      "date": 1466510106046
    },
    {
      "type": "add",
      "item": {
        "type": "factory",
        "id": "c7ecab33a49fecfd"
      },
      "after": "b49921a34e56ed19",
      "id": "c7ecab33a49fecfd",
      "date": 1466510110271
    },
    {
      "type": "edit",
      "id": "d4daf6d3eb816746",
      "item": {
        "type": "paragraph",
        "id": "d4daf6d3eb816746",
        "text": "Is the same as (in a non English-like language):\n\n   it := myObject.GetFooBar()\n\nOr something like:\n\n   copy myObject\n\n"
      },
      "date": 1466510114279
    },
    {
      "type": "add",
      "id": "d4017c66c3966aad",
      "item": {
        "type": "paragraph",
        "id": "d4017c66c3966aad",
        "text": "Is the same as (again, in a non English-like language):\n\n"
      },
      "after": "d4daf6d3eb816746",
      "date": 1466510116560
    },
    {
      "type": "add",
      "id": "5b3a074b2ce29b8b",
      "item": {
        "type": "paragraph",
        "id": "5b3a074b2ce29b8b",
        "text": " myObject.Copy()\n\n"
      },
      "after": "d4017c66c3966aad",
      "date": 1466510117969
    },
    {
      "type": "edit",
      "id": "d4daf6d3eb816746",
      "item": {
        "type": "paragraph",
        "id": "d4daf6d3eb816746",
        "text": "Is the same as (in a non English-like language):"
      },
      "date": 1466510135457
    },
    {
      "type": "add",
      "id": "f0e2b31e5c5f466d",
      "item": {
        "type": "paragraph",
        "id": "f0e2b31e5c5f466d",
        "text": "Or something like:\n\n   copy myObject\n\n"
      },
      "after": "d4daf6d3eb816746",
      "date": 1466510137096
    },
    {
      "type": "edit",
      "id": "c7ecab33a49fecfd",
      "item": {
        "type": "code",
        "id": "c7ecab33a49fecfd",
        "text": "it := myObject.GetFooBar()\n"
      },
      "date": 1466510141116
    },
    {
      "type": "move",
      "order": [
        "68b55a8a7e0c73fd",
        "19d9e3d08b431756",
        "bce26f4394dfa608",
        "cb1e07afbb39d0cd",
        "b49921a34e56ed19",
        "d4daf6d3eb816746",
        "c7ecab33a49fecfd",
        "f0e2b31e5c5f466d",
        "d4017c66c3966aad",
        "5b3a074b2ce29b8b",
        "10dac03dfa913de4",
        "f3c4c4cd7b490e63",
        "94fe7bf078e7fcce",
        "997f3d246d514873",
        "58ebefebf6b31871",
        "195d07249b7c95de",
        "0091253a229e9eed",
        "2c84376fc29de98c",
        "782e9e93680507d3",
        "0143cc98c7b3daf2"
      ],
      "id": "c7ecab33a49fecfd",
      "date": 1466510142877
    },
    {
      "type": "edit",
      "id": "f0e2b31e5c5f466d",
      "item": {
        "type": "paragraph",
        "id": "f0e2b31e5c5f466d",
        "text": "Or something like:"
      },
      "date": 1466510146496
    },
    {
      "type": "add",
      "id": "a2467a7d16dc9f52",
      "item": {
        "type": "paragraph",
        "id": "a2467a7d16dc9f52",
        "text": "\n"
      },
      "after": "f0e2b31e5c5f466d",
      "date": 1466510151210
    },
    {
      "type": "add",
      "item": {
        "type": "code",
        "id": "10d841f02b87e951",
        "text": "copy myObject"
      },
      "after": "f0e2b31e5c5f466d",
      "id": "10d841f02b87e951",
      "date": 1466510163283
    },
    {
      "type": "edit",
      "id": "5b3a074b2ce29b8b",
      "item": {
        "type": "paragraph",
        "id": "5b3a074b2ce29b8b",
        "text": "\n"
      },
      "date": 1466510169275
    },
    {
      "type": "add",
      "item": {
        "type": "code",
        "id": "f8c6fb736cd1ef54",
        "text": "myObject.Copy()"
      },
      "after": "d4017c66c3966aad",
      "id": "f8c6fb736cd1ef54",
      "date": 1466510177663
    },
    {
      "type": "edit",
      "id": "10dac03dfa913de4",
      "item": {
        "type": "paragraph",
        "id": "10dac03dfa913de4",
        "text": "Therefore, I have absolutely no hesitation in saying that LiveCode is object-oriented (for some definition of object-oriented). Indeed, it always has been - everyone who has ever programming in an xTalk had been doing object-oriented programming since it started to become 'popular' ([[HyperCard]] appeared in 1987, [[Cfront]] - the original C++ - appeared in 1985 - although the first 'object oriented' languages such as [[Simula]] appeared perhaps a decade before)."
      },
      "date": 1466510222630
    }
  ]
}