{
  "title": "Objects Or Controls",
  "story": [
    {
      "type": "paragraph",
      "id": "d8f7bdc4090624e7",
      "text": "I started a long time ago to name handlers with the concept of \"object\" rather than \"control\" - it was more intuitive. "
    },
    {
      "type": "paragraph",
      "id": "d9297ca6ba5f8a51",
      "text": "The word \"object\" has associations for the new user which makes it easier to grasp the related concepts of \"property\" and so forth. "
    },
    {
      "type": "paragraph",
      "id": "a275ede126d6b900",
      "text": "[[Objects in Livecode]]"
    },
    {
      "type": "paragraph",
      "id": "0cbfcfdf651abde6",
      "text": "[[Livecode]] is rooted in the object-oriented paradigm of [[Smalltalk]], and [[HyperCard]] - and many of the concepts such a \"stack\", \"card\" and \"field\" etc are layered on top of this metaphor. "
    },
    {
      "type": "paragraph",
      "id": "30b8f45240cc1eb8",
      "text": "The problem is that they are not pure objects in a technical sense, and the term is sort of reserved for a possible future expansion of the vocabulary. I am not sure if this will ever happen, and in the mean time we are left with a clear metaphor, and a confusing reality. I've decided to live with it :)\n\nSo when I refer to a \"field\" in a variable I use \"fieldObject\" rather than \"fieldControl\", or with a virtual property I use \"put the field_Object of this card...\" rather than \"field_Control\". This is partly because i don;t want to confuse (myself) and other readers with a terminology that sound too much like Model View Controller architecture - or the idea that you are \"doing something\" ie \"controlling\" the concept in question.\n\nSo my answer is that while creating an abstraction in how I code, I name things using the best metaphor I can find, so often I will think in terms of concrete objects, with properties that may or may not be implemented with a \"control\", a \"group\", or more recently a \"widget\". The most abstract concept is \"object\" which can refer to any of those - but I try to avoid it where possible and use a more explicit name of the term \"view\" - so \"textView\" or \"the index_View of this card\"."
    },
    {
      "type": "markdown",
      "id": "fd6ff26276b0cd7a",
      "text": "# See also"
    },
    {
      "type": "reference",
      "id": "fde12d0f3c7866c7",
      "site": "docs.livecode.world",
      "slug": "objects-in-livecode",
      "title": "Objects in Livecode",
      "text": "An object (regardless of what language it is rendered in, or with whatever specific kind of 'oop' methodology you care to subscribe to) is simply some state (i.e. variables which are distinct for each instance of the object) with an associated list of handlers/methods/functions which act on that state. "
    },
    {
      "type": "reference",
      "id": "635902ab4eb4339c",
      "site": "docs.livecode.world",
      "slug": "object-oriented-programming",
      "title": "Object-oriented programming",
      "text": "As in other object-oriented languages, the central concept in Smalltalk-80 (but not in Smalltalk-72) is that of an ''object''. "
    },
    {
      "type": "reference",
      "id": "bae870e81d65200d",
      "site": "docs.livecode.world",
      "slug": "smalltalk",
      "title": "Smalltalk",
      "text": "Smalltalk is an object-oriented, dynamically typed, reflective programming language. "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Objects Or Controls",
        "story": []
      },
      "date": 1466322614013
    },
    {
      "item": {
        "type": "factory",
        "id": "d8f7bdc4090624e7"
      },
      "id": "d8f7bdc4090624e7",
      "type": "add",
      "date": 1466322615099
    },
    {
      "type": "edit",
      "id": "d8f7bdc4090624e7",
      "item": {
        "type": "paragraph",
        "id": "d8f7bdc4090624e7",
        "text": "I started a long time ago to name handlers with the concept of \"object\" rather than \"control\" - it was more intuitive. The word \"object\" has associations for the new user which makes it easier to grasp the related concepts of \"property\" and so forth. Livecode is rooted in the object-oriented paradigm of small-talk, and HyperCard - and many of the concepts such a \"stack\", \"card\" and \"field\" etc are layered on top of this metaphor. The problem is that they are not pure objects in a technical sense, and the term is sort of reserved for a possible future expansion of the vocabulary. I am not sure if this will ever happen, and in the mean time we are left with a clear metaphor, and a confusing reality. I've decided to live with it :)\n\nSo when I refer to a \"field\" in a variable I use \"fieldObject\" rather than \"fieldControl\", or with a virtual property I use \"put the field_Object of this card...\" rather than \"field_Control\". This is partly because i don;t want to confuse (myself) and other readers with a terminology that sound too much like Model View Controller architecture - or the idea that you are \"doing something\" ie \"controlling\" the concept in question.\n\nSo my answer is that while creating an abstraction in how I code, I name things using the best metaphor I can find, so often I will think in terms of concrete objects, with properties that may or may not be implemented with a \"control\", a \"group\", or more recently a \"widget\". The most abstract concept is \"object\" which can refer to any of those - but I try to avoid it where possible and use a more explicit name of the term \"view\" - so \"textView\" or \"the index_View of this card\"."
      },
      "date": 1466322623828
    },
    {
      "type": "edit",
      "id": "d8f7bdc4090624e7",
      "item": {
        "type": "paragraph",
        "id": "d8f7bdc4090624e7",
        "text": "I started a long time ago to name handlers with the concept of \"object\" rather than \"control\" - it was more intuitive. "
      },
      "date": 1466322633605
    },
    {
      "type": "add",
      "id": "d9297ca6ba5f8a51",
      "item": {
        "type": "paragraph",
        "id": "d9297ca6ba5f8a51",
        "text": "The word \"object\" has associations for the new user which makes it easier to grasp the related concepts of \"property\" and so forth. "
      },
      "after": "d8f7bdc4090624e7",
      "date": 1466322645731
    },
    {
      "type": "add",
      "id": "0cbfcfdf651abde6",
      "item": {
        "type": "paragraph",
        "id": "0cbfcfdf651abde6",
        "text": "[[Livecode]] is rooted in the object-oriented paradigm of [[Small-talk]], and [[HyperCard]] - and many of the concepts such a \"stack\", \"card\" and \"field\" etc are layered on top of this metaphor. "
      },
      "after": "d9297ca6ba5f8a51",
      "date": 1466322667132
    },
    {
      "type": "add",
      "id": "30b8f45240cc1eb8",
      "item": {
        "type": "paragraph",
        "id": "30b8f45240cc1eb8",
        "text": "The problem is that they are not pure objects in a technical sense, and the term is sort of reserved for a possible future expansion of the vocabulary. I am not sure if this will ever happen, and in the mean time we are left with a clear metaphor, and a confusing reality. I've decided to live with it :)\n\nSo when I refer to a \"field\" in a variable I use \"fieldObject\" rather than \"fieldControl\", or with a virtual property I use \"put the field_Object of this card...\" rather than \"field_Control\". This is partly because i don;t want to confuse (myself) and other readers with a terminology that sound too much like Model View Controller architecture - or the idea that you are \"doing something\" ie \"controlling\" the concept in question.\n\nSo my answer is that while creating an abstraction in how I code, I name things using the best metaphor I can find, so often I will think in terms of concrete objects, with properties that may or may not be implemented with a \"control\", a \"group\", or more recently a \"widget\". The most abstract concept is \"object\" which can refer to any of those - but I try to avoid it where possible and use a more explicit name of the term \"view\" - so \"textView\" or \"the index_View of this card\"."
      },
      "after": "0cbfcfdf651abde6",
      "date": 1466322668941
    },
    {
      "type": "edit",
      "id": "0cbfcfdf651abde6",
      "item": {
        "type": "paragraph",
        "id": "0cbfcfdf651abde6",
        "text": "[[Livecode]] is rooted in the object-oriented paradigm of [[Smalltalk]], and [[HyperCard]] - and many of the concepts such a \"stack\", \"card\" and \"field\" etc are layered on top of this metaphor. "
      },
      "date": 1466322694830
    },
    {
      "item": {
        "type": "factory",
        "id": "fd6ff26276b0cd7a"
      },
      "id": "fd6ff26276b0cd7a",
      "type": "add",
      "after": "30b8f45240cc1eb8",
      "date": 1466430676504
    },
    {
      "type": "edit",
      "id": "fd6ff26276b0cd7a",
      "item": {
        "type": "markdown",
        "id": "fd6ff26276b0cd7a",
        "text": "# See also\n\n* [[Object Orientation]]"
      },
      "date": 1466430701547
    },
    {
      "item": {
        "type": "factory",
        "id": "635902ab4eb4339c"
      },
      "id": "635902ab4eb4339c",
      "type": "add",
      "after": "fd6ff26276b0cd7a",
      "date": 1466509319152
    },
    {
      "type": "edit",
      "id": "635902ab4eb4339c",
      "item": {
        "type": "reference",
        "id": "635902ab4eb4339c",
        "site": "docs.livecode.world",
        "slug": "object-oriented-programming",
        "title": "Object-oriented programming",
        "text": "As in other object-oriented languages, the central concept in Smalltalk-80 (but not in Smalltalk-72) is that of an ''object''. "
      },
      "date": 1466509331010
    },
    {
      "item": {
        "type": "factory",
        "id": "bae870e81d65200d"
      },
      "id": "bae870e81d65200d",
      "type": "add",
      "after": "635902ab4eb4339c",
      "date": 1466509342475
    },
    {
      "type": "edit",
      "id": "bae870e81d65200d",
      "item": {
        "type": "reference",
        "id": "bae870e81d65200d",
        "site": "docs.livecode.world",
        "slug": "smalltalk",
        "title": "Smalltalk",
        "text": "Smalltalk is an object-oriented, dynamically typed, reflective programming language. Smalltalk was created as the language to underpin the \"new world\" of computing exemplified by \"humanâ€“computer symbiosis.\" It was designed and created in part for educational use, more so for constructionist learning, at the Learning Research Group (LRG) of Xerox PARC by Alan Kay, Dan Ingalls, Adele Goldberg, Ted Kaehler, Scott Wallace, and others during the 1970s - [https://en.wikipedia.org/wiki/Smalltalk wikipedia]"
      },
      "date": 1466509345287
    },
    {
      "type": "edit",
      "id": "bae870e81d65200d",
      "item": {
        "type": "reference",
        "id": "bae870e81d65200d",
        "site": "docs.livecode.world",
        "slug": "smalltalk",
        "title": "Smalltalk",
        "text": "Smalltalk is an object-oriented, dynamically typed, reflective programming language. "
      },
      "date": 1466509365153
    },
    {
      "type": "edit",
      "id": "fd6ff26276b0cd7a",
      "item": {
        "type": "markdown",
        "id": "fd6ff26276b0cd7a",
        "text": "# See also"
      },
      "date": 1466509468918
    },
    {
      "type": "add",
      "id": "a275ede126d6b900",
      "item": {
        "type": "paragraph",
        "id": "a275ede126d6b900",
        "text": "[[Objects in Livecode]]"
      },
      "after": "d9297ca6ba5f8a51",
      "date": 1466509567928
    },
    {
      "item": {
        "type": "factory",
        "id": "fde12d0f3c7866c7"
      },
      "id": "fde12d0f3c7866c7",
      "type": "add",
      "after": "bae870e81d65200d",
      "date": 1466510074040
    },
    {
      "type": "edit",
      "id": "fde12d0f3c7866c7",
      "item": {
        "type": "reference",
        "id": "fde12d0f3c7866c7",
        "site": "docs.livecode.world",
        "slug": "objects-in-livecode",
        "title": "Objects in Livecode",
        "text": "An object (regardless of what language it is rendered in, or with whatever specific kind of 'oop' methodology you care to subscribe to) is simply some state (i.e. variables which are distinct for each instance of the object) with an associated list of handlers/methods/functions which act on that state. "
      },
      "date": 1466510076529
    },
    {
      "type": "move",
      "order": [
        "d8f7bdc4090624e7",
        "d9297ca6ba5f8a51",
        "a275ede126d6b900",
        "0cbfcfdf651abde6",
        "30b8f45240cc1eb8",
        "fd6ff26276b0cd7a",
        "fde12d0f3c7866c7",
        "635902ab4eb4339c",
        "bae870e81d65200d"
      ],
      "id": "fde12d0f3c7866c7",
      "date": 1466510078410
    },
    {
      "item": {
        "type": "factory",
        "id": "b49921a34e56ed19"
      },
      "id": "b49921a34e56ed19",
      "type": "add",
      "after": "bae870e81d65200d",
      "date": 1466510081932
    },
    {
      "type": "remove",
      "id": "b49921a34e56ed19",
      "date": 1466510084662
    },
    {
      "item": {
        "type": "factory",
        "id": "c7ecab33a49fecfd"
      },
      "id": "c7ecab33a49fecfd",
      "type": "add",
      "after": "bae870e81d65200d",
      "date": 1466510108128
    },
    {
      "type": "remove",
      "id": "c7ecab33a49fecfd",
      "date": 1466510110269
    },
    {
      "item": {
        "type": "factory",
        "id": "10d841f02b87e951"
      },
      "id": "10d841f02b87e951",
      "type": "add",
      "after": "bae870e81d65200d",
      "date": 1466510153109
    },
    {
      "type": "edit",
      "id": "10d841f02b87e951",
      "item": {
        "type": "code",
        "id": "10d841f02b87e951",
        "text": "copy myObject"
      },
      "date": 1466510159060
    },
    {
      "type": "remove",
      "id": "10d841f02b87e951",
      "date": 1466510163280
    },
    {
      "item": {
        "type": "factory",
        "id": "f8c6fb736cd1ef54"
      },
      "id": "f8c6fb736cd1ef54",
      "type": "add",
      "after": "bae870e81d65200d",
      "date": 1466510165453
    },
    {
      "type": "edit",
      "id": "f8c6fb736cd1ef54",
      "item": {
        "type": "code",
        "id": "f8c6fb736cd1ef54",
        "text": "myObject.Copy()"
      },
      "date": 1466510174628
    },
    {
      "type": "remove",
      "id": "f8c6fb736cd1ef54",
      "date": 1466510177661
    }
  ]
}