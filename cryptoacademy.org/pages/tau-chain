{
  "title": "Tau Chain",
  "story": [
    {
      "type": "paragraph",
      "id": "deb7edfb7ebedf00",
      "text": "τ-chain (pronounced tau-chain) is a decentralized peer-to-peer network having three unified faces: Rules, Proofs, and Computer Programs, allowing a generalization of virtually any centralized or decentralized P2P network, together with many new abilities, as we present on this note - [http://tauchain.org/tauchain.pdf pdf]"
    },
    {
      "type": "markdown",
      "id": "2f8a4e6657c92236",
      "text": "# See also\n\n* [[The DAO Hack]]\n* [[DAO Private Keys]]\n* [[Multisigs Can't Secure DAO Keys]]\n* [[DAO Design Jam]]"
    },
    {
      "type": "paragraph",
      "id": "decf307cf124dac3",
      "text": "For more information see:\n[http://www.idni.org/blog idni.org] or \n[http://tauchain.org/tauchain.pdf tauchain.org]"
    },
    {
      "type": "video",
      "id": "ce0aa3ab34635a94",
      "text": "YOUTUBE 3ORpi2MMJrA\nInterview with Ohad Asor of [[Tau Chain]]. Tau-chain is a fully decentralized P2P network being a generalization of many centralized and decentralized P2P networks, including the [[Blockchain]]. See Tau chain on [http://cointelegraph.com/news/tau-chain-a-decentralized-app-store-with-greater-flexibility-than-ethereum cointelegraph.com]"
    },
    {
      "type": "pagefold",
      "id": "01453e080a2b67b2",
      "text": "Quote"
    },
    {
      "type": "paragraph",
      "id": "51f0b75e61d97634",
      "text": "If law-making is a game, then it is a game in which changing the rules is a move. - [[Peter Suber]] presenting [[Nomic]]."
    },
    {
      "type": "pagefold",
      "id": "003959783fc33402",
      "text": "."
    },
    {
      "type": "video",
      "id": "ddd3af2191cb04a9",
      "text": "YOUTUBE 6G8mTCtv8d8\nOn this talk Ohad will explain about Zennet together with Q&A - [http://zennet.sc zennet.sc]"
    },
    {
      "type": "paragraph",
      "id": "b5780e80e88bc893",
      "text": "And here on [https://soundcloud.com/mindtomatter/ltb-e261-understanding-tauchains soundcloud]"
    },
    {
      "type": "paragraph",
      "id": "43f7bfd5790ce4e7",
      "text": "A DHT is a general scheme for decentralized file storage. Every file has a unique identifier (hash) and is retrieved by it."
    },
    {
      "type": "markdown",
      "id": "cce4ec4638cbdae8",
      "text": "#DHT (Distributed Hash Tables)"
    },
    {
      "type": "markdown",
      "id": "0ccc2d8a5d959355",
      "text": "#DHT -> Kademlia"
    },
    {
      "type": "image",
      "id": "f833a46eed51d551",
      "url": "data:image/jpeg;base64,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ef8AXUf+gLTbmdoQm1VLMT95toGAT1/CnSB4by53RSlZHDqyIWBG0Dt7g012SRdslvK464aBj/StE9CGtSrJq8KfwSEDknjp2PXvV2GUTRLIoIDDoRgioisJOTaSHkn/AI9279e1PWQKoVYJgo4AEDcfpRcVhEmMOo/JDJKzRcBAPXuTgCre2+m+/JHbL6Rje35ngfkaisVd7x5jG6RhAgLrtLHOTwefT860ah7lrYqx2FujiR1Msg6PKdxH0z0/CrNLRSGFFFFABRRRQAUUUUAFFFFABUc0Mc8ZjlQMp7H+dSUUAZOoi4ttPuI2zcQNGQG/jT6+o9+v161LVm/ieaxnijGXaMhR6nFUhMSOYLgH0MLcfpVRJkVP7TVbiSOSMqq7sMM87c+o9j0Joh1aGUouyQFiq5xwCff68VYfynGHtZGHvbsf6UmId277JJnIOfs7dR07VVybFiptL/5Btv8A7gqqZuP9TcH/ALYt/hV3T43hsYI5BtcINw9D6VMioliiiipKCiikoAWiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Z",
      "caption": "Uploaded image",
      "text": "Diagram explaining the core concepts of [[Tau Chain]] and how they relate to [[Bitcoin]] and [[Ethereum]]."
    },
    {
      "type": "paragraph",
      "id": "566e3d6efc3b587c",
      "text": "[[Kademlia]] is a special case of [[DHT]] using the cryptographic hash SHA1 and uses an efficient metric (the XOR metric) that significantly speeds up the process of finding a node storing a file given its hash."
    },
    {
      "type": "markdown",
      "id": "4e8580b94f794329",
      "text": "# Kademlia -> Bittorrent"
    },
    {
      "type": "paragraph",
      "id": "2d1ee7ca108b7602",
      "text": "[[Bittorrent]] is a special case of Kademlia and is the most successful and popular decentralized file sharing network nowadays."
    },
    {
      "type": "markdown",
      "id": "e93401bb80e4bc10",
      "text": "# Blockchain"
    },
    {
      "type": "paragraph",
      "id": "91c5253527674948",
      "text": "An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below)."
    },
    {
      "type": "markdown",
      "id": "8dd745ba93273d44",
      "text": "# DHT -> Blockchain"
    },
    {
      "type": "paragraph",
      "id": "ab4af9af9419cd04",
      "text": "Blockchain's form of storing and transferring the blocks is also a special case of DHT."
    },
    {
      "type": "markdown",
      "id": "14795b8532ba5515",
      "text": "# Proof"
    },
    {
      "type": "paragraph",
      "id": "20fa7497b8be6ca1",
      "text": "A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. "
    },
    {
      "type": "paragraph",
      "id": "a5fd8f7d06f688af",
      "text": "A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. "
    },
    {
      "type": "paragraph",
      "id": "4fb4b1f45bfab7b8",
      "text": "The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof [[Type Theory]] literature for more information."
    },
    {
      "type": "markdown",
      "id": "019c471e9bb534b1",
      "text": "# Proof -> Logic"
    },
    {
      "type": "paragraph",
      "id": "8372e0d253ded1cb",
      "text": "A logical proof is a proof within a formal system of logic, as used regularly in math."
    },
    {
      "type": "markdown",
      "id": "1170e9df814a97db",
      "text": "# Proof -> Crypto"
    },
    {
      "type": "paragraph",
      "id": "22cddf4e9509eb02",
      "text": "Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. "
    },
    {
      "type": "paragraph",
      "id": "6a2be185a37b6d3a",
      "text": "As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules."
    },
    {
      "type": "markdown",
      "id": "9aff3b0f59a2e055",
      "text": "# Code"
    },
    {
      "type": "paragraph",
      "id": "81d1e43a7015e55e",
      "text": "Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the [[Turing Machine]]. "
    },
    {
      "type": "paragraph",
      "id": "862dbbe04057d297",
      "text": "A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out."
    },
    {
      "type": "markdown",
      "id": "e1dba67ab39e8191",
      "text": "# Code -> Undecidable"
    },
    {
      "type": "paragraph",
      "id": "0b2e53cf0f23eb6f",
      "text": "Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction."
    },
    {
      "type": "paragraph",
      "id": "9a9ef803eabe12ec",
      "text": "Around that time, several such results would change what mathematicians believed for ages. I'll mention here only [[Godel]] and [[Russell]]. Godel has constructed a question that, as in the [[Halting Problem]], both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! "
    },
    {
      "type": "paragraph",
      "id": "c9976459453b3b6a",
      "text": "There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. "
    },
    {
      "type": "paragraph",
      "id": "3f81fc6fac43608f",
      "text": "By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof."
    },
    {
      "type": "paragraph",
      "id": "848d8ad478bd25c2",
      "text": "Last example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics."
    },
    {
      "type": "paragraph",
      "id": "5fd04b10c949eaff",
      "text": "When computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence."
    },
    {
      "type": "markdown",
      "id": "a813ab831ae0c2b7",
      "text": "# Code -> Decidable"
    },
    {
      "type": "paragraph",
      "id": "2afa86e3fbb39e3f",
      "text": "Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information."
    },
    {
      "type": "paragraph",
      "id": "df4d522f98b03600",
      "text": "Over the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us."
    },
    {
      "type": "markdown",
      "id": "ee5513276bb0275a",
      "text": "# Decidable -> Tau"
    },
    {
      "type": "paragraph",
      "id": "6cad14e2c936dbd1",
      "text": "Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them."
    },
    {
      "type": "paragraph",
      "id": "bac1179d5e08ade6",
      "text": "Taking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth."
    },
    {
      "type": "markdown",
      "id": "64176451f49e1cbe",
      "text": "# Undecidable -> Ethereum"
    },
    {
      "type": "paragraph",
      "id": "33a41498c62a9691",
      "text": "As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem."
    },
    {
      "type": "markdown",
      "id": "910fe8de6cbddecf",
      "text": "# Contracts -> Ethereum"
    },
    {
      "type": "paragraph",
      "id": "dba48b80dfbca97f",
      "text": "Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts."
    },
    {
      "type": "markdown",
      "id": "d40b46c0973b1280",
      "text": "# General Purpose -> Tau"
    },
    {
      "type": "paragraph",
      "id": "2b1b149e797aa9b8",
      "text": "Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages."
    },
    {
      "type": "markdown",
      "id": "7b3750491133f8d2",
      "text": "# Rules -> Fixed -> Bitcoin/Ethereum"
    },
    {
      "type": "paragraph",
      "id": "17bbb3e729a161c6",
      "text": "The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed."
    },
    {
      "type": "markdown",
      "id": "91ab4927eb9b2bdc",
      "text": "# Rules -> Dynamic -> Tau"
    },
    {
      "type": "paragraph",
      "id": "29117ae8363c71be",
      "text": "Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block."
    },
    {
      "type": "markdown",
      "id": "be6e4fa9d2082ddd",
      "text": "# Blockchain -> Tau, Kademlia -> Tau"
    },
    {
      "type": "paragraph",
      "id": "d391535bf07afa64",
      "text": "Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code."
    },
    {
      "type": "paragraph",
      "id": "3ed743bed259d465",
      "text": "Below we elaborate more on Tau's features and properties:"
    },
    {
      "type": "markdown",
      "id": "a5a43672d2b2991b",
      "text": "# Programming Language"
    },
    {
      "type": "paragraph",
      "id": "bf77ffaf642b29b8",
      "text": "Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language."
    },
    {
      "type": "paragraph",
      "id": "5e1e004315c97fa9",
      "text": "It is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins."
    },
    {
      "type": "markdown",
      "id": "b45ca24151f74af2",
      "text": "# Software Development"
    },
    {
      "type": "paragraph",
      "id": "576d17bc62bd5f96",
      "text": "Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages)."
    },
    {
      "type": "paragraph",
      "id": "f6e38934ec3e67c7",
      "text": "This allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it."
    },
    {
      "type": "paragraph",
      "id": "c52c6e3a97530eee",
      "text": "Now what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust."
    },
    {
      "type": "paragraph",
      "id": "e988613869acb4a7",
      "text": "Tau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken."
    },
    {
      "type": "paragraph",
      "id": "fc4f133269442c0d",
      "text": "It is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information)."
    },
    {
      "type": "markdown",
      "id": "481617af8e248dee",
      "text": "# Legal"
    },
    {
      "type": "paragraph",
      "id": "852287d7e1959f2d",
      "text": "Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions."
    },
    {
      "type": "markdown",
      "id": "17ca8ff2255e9b2d",
      "text": "# Economy"
    },
    {
      "type": "paragraph",
      "id": "55540cf839d1d7fa",
      "text": "The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras - [https://github.com/naturalog/Bitagoras github]"
    },
    {
      "type": "markdown",
      "id": "e77247e736149821",
      "text": "# Information"
    },
    {
      "type": "paragraph",
      "id": "fef89757a5e4b418",
      "text": "Even with not-so-many users, Tau network will be able to download virtually the whole internet, practically giving everyone the same information Google has, and more: data can be queried and processed more meaningfully and collaboratively, so you could perform queries as you like. Imagine how your search would look like if you had the whole of Google's database! The futuristic search engine I've been talking about the past year is going to take place over Tau."
    },
    {
      "type": "paragraph",
      "id": "7ebf3780b45fe179",
      "text": "Another example of a nontrivial usage is the ability to find implications across sciences: one math problem might be isomorphic to some chemistry problem, and such correspondence can be easily detected and used over Tau."
    }
  ],
  "journal": [
    {
      "type": "edit",
      "id": "81d1e43a7015e55e",
      "item": {
        "type": "paragraph",
        "id": "81d1e43a7015e55e",
        "text": "Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the [[Turing Machine]]. "
      },
      "date": 1456069052617
    },
    {
      "type": "add",
      "id": "862dbbe04057d297",
      "item": {
        "type": "paragraph",
        "id": "862dbbe04057d297",
        "text": "A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out."
      },
      "after": "81d1e43a7015e55e",
      "date": 1456069047479
    },
    {
      "type": "edit",
      "id": "81d1e43a7015e55e",
      "item": {
        "type": "paragraph",
        "id": "81d1e43a7015e55e",
        "text": "Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. "
      },
      "date": 1456069042728
    },
    {
      "type": "edit",
      "id": "e1dba67ab39e8191",
      "item": {
        "type": "markdown",
        "id": "e1dba67ab39e8191",
        "text": "# Code -> Undecidable"
      },
      "date": 1456069033551
    },
    {
      "type": "add",
      "id": "3f81fc6fac43608f",
      "item": {
        "type": "paragraph",
        "id": "3f81fc6fac43608f",
        "text": "By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof."
      },
      "after": "c9976459453b3b6a",
      "date": 1456069020910
    },
    {
      "type": "add",
      "id": "c9976459453b3b6a",
      "item": {
        "type": "paragraph",
        "id": "c9976459453b3b6a",
        "text": "There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. "
      },
      "after": "9a9ef803eabe12ec",
      "date": 1456069019436
    },
    {
      "type": "add",
      "id": "9a9ef803eabe12ec",
      "item": {
        "type": "paragraph",
        "id": "9a9ef803eabe12ec",
        "text": "Around that time, several such results would change what mathematicians believed for ages. I'll mention here only [[Godel]] and [[Russell]]. Godel has constructed a question that, as in the [[Halting Problem]], both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! "
      },
      "after": "0b2e53cf0f23eb6f",
      "date": 1456069004921
    },
    {
      "type": "edit",
      "id": "0b2e53cf0f23eb6f",
      "item": {
        "type": "paragraph",
        "id": "0b2e53cf0f23eb6f",
        "text": "Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction."
      },
      "date": 1456068962540
    },
    {
      "type": "edit",
      "id": "003959783fc33402",
      "item": {
        "type": "pagefold",
        "id": "003959783fc33402",
        "text": "."
      },
      "date": 1456068899143
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "01453e080a2b67b2",
        "51f0b75e61d97634",
        "003959783fc33402",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "f833a46eed51d551",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "003959783fc33402",
      "date": 1456068895344
    },
    {
      "item": {
        "type": "factory",
        "id": "003959783fc33402"
      },
      "id": "003959783fc33402",
      "type": "add",
      "after": "7ebf3780b45fe179",
      "date": 1456068881462
    },
    {
      "type": "edit",
      "id": "01453e080a2b67b2",
      "item": {
        "type": "pagefold",
        "id": "01453e080a2b67b2",
        "text": "Quote"
      },
      "date": 1456068876195
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "01453e080a2b67b2",
        "51f0b75e61d97634",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "f833a46eed51d551",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "01453e080a2b67b2",
      "date": 1456068860581
    },
    {
      "item": {
        "type": "factory",
        "id": "01453e080a2b67b2"
      },
      "id": "01453e080a2b67b2",
      "type": "add",
      "after": "7ebf3780b45fe179",
      "date": 1456068843229
    },
    {
      "type": "edit",
      "id": "cce4ec4638cbdae8",
      "item": {
        "type": "markdown",
        "id": "cce4ec4638cbdae8",
        "text": "#DHT (Distributed Hash Tables)"
      },
      "date": 1456068825246
    },
    {
      "type": "edit",
      "id": "0ccc2d8a5d959355",
      "item": {
        "type": "markdown",
        "id": "0ccc2d8a5d959355",
        "text": "#DHT -> Kademlia"
      },
      "date": 1456068818574
    },
    {
      "type": "edit",
      "id": "3ed743bed259d465",
      "item": {
        "type": "paragraph",
        "id": "3ed743bed259d465",
        "text": "Below we elaborate more on Tau's features and properties:"
      },
      "date": 1456068777886
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "51f0b75e61d97634",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "f833a46eed51d551",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "f833a46eed51d551",
      "date": 1456068715383
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "51f0b75e61d97634",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "566e3d6efc3b587c",
        "f833a46eed51d551",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "f833a46eed51d551",
      "date": 1456068711002
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "51f0b75e61d97634",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "f833a46eed51d551",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "f833a46eed51d551",
      "date": 1456068701802
    },
    {
      "type": "edit",
      "id": "f833a46eed51d551",
      "item": {
        "type": "image",
        "id": "f833a46eed51d551",
        "url": "data:image/jpeg;base64,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ef8AXUf+gLTbmdoQm1VLMT95toGAT1/CnSB4by53RSlZHDqyIWBG0Dt7g012SRdslvK464aBj/StE9CGtSrJq8KfwSEDknjp2PXvV2GUTRLIoIDDoRgioisJOTaSHkn/AI9279e1PWQKoVYJgo4AEDcfpRcVhEmMOo/JDJKzRcBAPXuTgCre2+m+/JHbL6Rje35ngfkaisVd7x5jG6RhAgLrtLHOTwefT860ah7lrYqx2FujiR1Msg6PKdxH0z0/CrNLRSGFFFFABRRRQAUUUUAFFFFABUc0Mc8ZjlQMp7H+dSUUAZOoi4ttPuI2zcQNGQG/jT6+o9+v161LVm/ieaxnijGXaMhR6nFUhMSOYLgH0MLcfpVRJkVP7TVbiSOSMqq7sMM87c+o9j0Joh1aGUouyQFiq5xwCff68VYfynGHtZGHvbsf6UmId277JJnIOfs7dR07VVybFiptL/5Btv8A7gqqZuP9TcH/ALYt/hV3T43hsYI5BtcINw9D6VMioliiiipKCiikoAWiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Z",
        "caption": "Uploaded image",
        "text": "Diagram explaining the core concepts of [[Tau Chain]] and how they relate to [[Bitcoin]] and [[Ethereum]]."
      },
      "date": 1456068697656
    },
    {
      "type": "edit",
      "id": "ce0aa3ab34635a94",
      "item": {
        "type": "video",
        "id": "ce0aa3ab34635a94",
        "text": "YOUTUBE 3ORpi2MMJrA\nInterview with Ohad Asor of [[Tau Chain]]. Tau-chain is a fully decentralized P2P network being a generalization of many centralized and decentralized P2P networks, including the [[Blockchain]]. See Tau chain on [http://cointelegraph.com/news/tau-chain-a-decentralized-app-store-with-greater-flexibility-than-ethereum cointelegraph.com]"
      },
      "date": 1456068642509
    },
    {
      "type": "remove",
      "id": "bf950a5203dbac9b",
      "date": 1456068637281
    },
    {
      "type": "edit",
      "id": "deb7edfb7ebedf00",
      "item": {
        "type": "paragraph",
        "id": "deb7edfb7ebedf00",
        "text": "τ-chain (pronounced tau-chain) is a decentralized peer-to-peer network having three unified faces: Rules, Proofs, and Computer Programs, allowing a generalization of virtually any centralized or decentralized P2P network, together with many new abilities, as we present on this note - [http://tauchain.org/tauchain.pdf pdf]"
      },
      "date": 1456068622569
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "bf950a5203dbac9b",
        "ce0aa3ab34635a94",
        "51f0b75e61d97634",
        "f833a46eed51d551",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "51f0b75e61d97634",
      "date": 1456068574442
    },
    {
      "type": "edit",
      "id": "9aff3b0f59a2e055",
      "item": {
        "type": "markdown",
        "id": "9aff3b0f59a2e055",
        "text": "# Code"
      },
      "date": 1456068561004
    },
    {
      "type": "edit",
      "id": "9aff3b0f59a2e055",
      "item": {
        "type": "paragraph",
        "id": "9aff3b0f59a2e055",
        "text": "# Code"
      },
      "date": 1456068560124
    },
    {
      "type": "edit",
      "id": "e1dba67ab39e8191",
      "item": {
        "type": "markdown",
        "id": "e1dba67ab39e8191",
        "text": "# Code->Undecidable"
      },
      "date": 1456068555552
    },
    {
      "type": "edit",
      "id": "a813ab831ae0c2b7",
      "item": {
        "type": "markdown",
        "id": "a813ab831ae0c2b7",
        "text": "# Code -> Decidable"
      },
      "date": 1456068551164
    },
    {
      "type": "edit",
      "id": "ee5513276bb0275a",
      "item": {
        "type": "markdown",
        "id": "ee5513276bb0275a",
        "text": "# Decidable -> Tau"
      },
      "date": 1456068547248
    },
    {
      "type": "edit",
      "id": "64176451f49e1cbe",
      "item": {
        "type": "markdown",
        "id": "64176451f49e1cbe",
        "text": "# Undecidable -> Ethereum"
      },
      "date": 1456068543645
    },
    {
      "type": "edit",
      "id": "910fe8de6cbddecf",
      "item": {
        "type": "markdown",
        "id": "910fe8de6cbddecf",
        "text": "# Contracts -> Ethereum"
      },
      "date": 1456068542435
    },
    {
      "type": "edit",
      "id": "d40b46c0973b1280",
      "item": {
        "type": "markdown",
        "id": "d40b46c0973b1280",
        "text": "# General Purpose -> Tau"
      },
      "date": 1456068540199
    },
    {
      "type": "edit",
      "id": "7b3750491133f8d2",
      "item": {
        "type": "markdown",
        "id": "7b3750491133f8d2",
        "text": "# Rules -> Fixed -> Bitcoin/Ethereum"
      },
      "date": 1456068538383
    },
    {
      "type": "edit",
      "id": "91ab4927eb9b2bdc",
      "item": {
        "type": "markdown",
        "id": "91ab4927eb9b2bdc",
        "text": "# Rules -> Dynamic -> Tau"
      },
      "date": 1456068536926
    },
    {
      "type": "edit",
      "id": "be6e4fa9d2082ddd",
      "item": {
        "type": "markdown",
        "id": "be6e4fa9d2082ddd",
        "text": "# Blockchain -> Tau, Kademlia -> Tau"
      },
      "date": 1456068534556
    },
    {
      "type": "edit",
      "id": "a5a43672d2b2991b",
      "item": {
        "type": "markdown",
        "id": "a5a43672d2b2991b",
        "text": "# Programming Language"
      },
      "date": 1456068531846
    },
    {
      "type": "edit",
      "id": "b45ca24151f74af2",
      "item": {
        "type": "markdown",
        "id": "b45ca24151f74af2",
        "text": "# Software Development"
      },
      "date": 1456068528853
    },
    {
      "type": "add",
      "id": "e988613869acb4a7",
      "item": {
        "type": "paragraph",
        "id": "e988613869acb4a7",
        "text": "Tau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken."
      },
      "after": "c52c6e3a97530eee",
      "date": 1456068520609
    },
    {
      "type": "add",
      "id": "c52c6e3a97530eee",
      "item": {
        "type": "paragraph",
        "id": "c52c6e3a97530eee",
        "text": "Now what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust."
      },
      "after": "f6e38934ec3e67c7",
      "date": 1456068516558
    },
    {
      "type": "add",
      "id": "f6e38934ec3e67c7",
      "item": {
        "type": "paragraph",
        "id": "f6e38934ec3e67c7",
        "text": "This allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it."
      },
      "after": "576d17bc62bd5f96",
      "date": 1456068514159
    },
    {
      "type": "add",
      "id": "576d17bc62bd5f96",
      "item": {
        "type": "paragraph",
        "id": "576d17bc62bd5f96",
        "text": "Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages)."
      },
      "after": "b45ca24151f74af2",
      "date": 1456068509573
    },
    {
      "type": "add",
      "id": "b45ca24151f74af2",
      "item": {
        "type": "paragraph",
        "id": "b45ca24151f74af2",
        "text": "# Software Development"
      },
      "after": "5e1e004315c97fa9",
      "date": 1456068507854
    },
    {
      "type": "add",
      "id": "5e1e004315c97fa9",
      "item": {
        "type": "paragraph",
        "id": "5e1e004315c97fa9",
        "text": "It is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins."
      },
      "after": "bf77ffaf642b29b8",
      "date": 1456068496790
    },
    {
      "type": "add",
      "id": "bf77ffaf642b29b8",
      "item": {
        "type": "paragraph",
        "id": "bf77ffaf642b29b8",
        "text": "Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language."
      },
      "after": "a5a43672d2b2991b",
      "date": 1456068493309
    },
    {
      "type": "add",
      "id": "a5a43672d2b2991b",
      "item": {
        "type": "paragraph",
        "id": "a5a43672d2b2991b",
        "text": "# Programming Language"
      },
      "after": "3ed743bed259d465",
      "date": 1456068489765
    },
    {
      "type": "add",
      "id": "3ed743bed259d465",
      "item": {
        "type": "paragraph",
        "id": "3ed743bed259d465",
        "text": "We have explained the chart. Now here is a bit more elaboration on Tau's features and properties:"
      },
      "after": "d391535bf07afa64",
      "date": 1456068482468
    },
    {
      "type": "add",
      "id": "d391535bf07afa64",
      "item": {
        "type": "paragraph",
        "id": "d391535bf07afa64",
        "text": "Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code."
      },
      "after": "be6e4fa9d2082ddd",
      "date": 1456068469892
    },
    {
      "type": "add",
      "id": "be6e4fa9d2082ddd",
      "item": {
        "type": "paragraph",
        "id": "be6e4fa9d2082ddd",
        "text": "# Blockchain -> Tau, Kademlia -> Tau"
      },
      "after": "29117ae8363c71be",
      "date": 1456068460491
    },
    {
      "type": "add",
      "id": "29117ae8363c71be",
      "item": {
        "type": "paragraph",
        "id": "29117ae8363c71be",
        "text": "Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block."
      },
      "after": "91ab4927eb9b2bdc",
      "date": 1456068440304
    },
    {
      "type": "add",
      "id": "91ab4927eb9b2bdc",
      "item": {
        "type": "paragraph",
        "id": "91ab4927eb9b2bdc",
        "text": "# Rules -> Dynamic -> Tau"
      },
      "after": "17bbb3e729a161c6",
      "date": 1456068436928
    },
    {
      "type": "add",
      "id": "17bbb3e729a161c6",
      "item": {
        "type": "paragraph",
        "id": "17bbb3e729a161c6",
        "text": "The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed."
      },
      "after": "7b3750491133f8d2",
      "date": 1456068420903
    },
    {
      "type": "add",
      "id": "7b3750491133f8d2",
      "item": {
        "type": "paragraph",
        "id": "7b3750491133f8d2",
        "text": "# Rules -> Fixed -> Bitcoin/Ethereum"
      },
      "after": "2b1b149e797aa9b8",
      "date": 1456068418822
    },
    {
      "type": "add",
      "id": "2b1b149e797aa9b8",
      "item": {
        "type": "paragraph",
        "id": "2b1b149e797aa9b8",
        "text": "Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages."
      },
      "after": "d40b46c0973b1280",
      "date": 1456068404862
    },
    {
      "type": "add",
      "id": "d40b46c0973b1280",
      "item": {
        "type": "paragraph",
        "id": "d40b46c0973b1280",
        "text": "# General Purpose -> Tau"
      },
      "after": "dba48b80dfbca97f",
      "date": 1456068395021
    },
    {
      "type": "edit",
      "id": "dba48b80dfbca97f",
      "item": {
        "type": "paragraph",
        "id": "dba48b80dfbca97f",
        "text": "Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts."
      },
      "date": 1456068385316
    },
    {
      "type": "edit",
      "id": "910fe8de6cbddecf",
      "item": {
        "type": "paragraph",
        "id": "910fe8de6cbddecf",
        "text": "# Contracts -> Ethereum"
      },
      "date": 1456068379781
    },
    {
      "type": "add",
      "id": "dba48b80dfbca97f",
      "item": {
        "type": "paragraph",
        "id": "dba48b80dfbca97f",
        "text": "Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken."
      },
      "after": "910fe8de6cbddecf",
      "date": 1456068371962
    },
    {
      "type": "add",
      "id": "910fe8de6cbddecf",
      "item": {
        "type": "paragraph",
        "id": "910fe8de6cbddecf",
        "text": "Contracts->Ethereum"
      },
      "after": "33a41498c62a9691",
      "date": 1456068370634
    },
    {
      "type": "add",
      "id": "33a41498c62a9691",
      "item": {
        "type": "paragraph",
        "id": "33a41498c62a9691",
        "text": "As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem."
      },
      "after": "64176451f49e1cbe",
      "date": 1456068362730
    },
    {
      "type": "add",
      "id": "64176451f49e1cbe",
      "item": {
        "type": "paragraph",
        "id": "64176451f49e1cbe",
        "text": "# Undecidable -> Ethereum"
      },
      "after": "bac1179d5e08ade6",
      "date": 1456068360673
    },
    {
      "type": "add",
      "id": "bac1179d5e08ade6",
      "item": {
        "type": "paragraph",
        "id": "bac1179d5e08ade6",
        "text": "Taking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth."
      },
      "after": "6cad14e2c936dbd1",
      "date": 1456068350020
    },
    {
      "type": "add",
      "id": "6cad14e2c936dbd1",
      "item": {
        "type": "paragraph",
        "id": "6cad14e2c936dbd1",
        "text": "Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them."
      },
      "after": "ee5513276bb0275a",
      "date": 1456068344490
    },
    {
      "type": "add",
      "id": "ee5513276bb0275a",
      "item": {
        "type": "paragraph",
        "id": "ee5513276bb0275a",
        "text": "# Decidable -> Tau"
      },
      "after": "df4d522f98b03600",
      "date": 1456068334288
    },
    {
      "type": "add",
      "id": "df4d522f98b03600",
      "item": {
        "type": "paragraph",
        "id": "df4d522f98b03600",
        "text": "Over the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us."
      },
      "after": "2afa86e3fbb39e3f",
      "date": 1456068325216
    },
    {
      "type": "add",
      "id": "2afa86e3fbb39e3f",
      "item": {
        "type": "paragraph",
        "id": "2afa86e3fbb39e3f",
        "text": "Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information."
      },
      "after": "a813ab831ae0c2b7",
      "date": 1456068317656
    },
    {
      "type": "add",
      "id": "a813ab831ae0c2b7",
      "item": {
        "type": "paragraph",
        "id": "a813ab831ae0c2b7",
        "text": "# Code -> Decidable"
      },
      "after": "5fd04b10c949eaff",
      "date": 1456068306255
    },
    {
      "type": "add",
      "id": "5fd04b10c949eaff",
      "item": {
        "type": "paragraph",
        "id": "5fd04b10c949eaff",
        "text": "When computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence."
      },
      "after": "848d8ad478bd25c2",
      "date": 1456068296894
    },
    {
      "type": "add",
      "id": "848d8ad478bd25c2",
      "item": {
        "type": "paragraph",
        "id": "848d8ad478bd25c2",
        "text": "Last example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics."
      },
      "after": "0b2e53cf0f23eb6f",
      "date": 1456068294150
    },
    {
      "type": "add",
      "id": "0b2e53cf0f23eb6f",
      "item": {
        "type": "paragraph",
        "id": "0b2e53cf0f23eb6f",
        "text": "Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof."
      },
      "after": "e1dba67ab39e8191",
      "date": 1456068289550
    },
    {
      "type": "add",
      "id": "e1dba67ab39e8191",
      "item": {
        "type": "paragraph",
        "id": "e1dba67ab39e8191",
        "text": "# Code->Undecidable"
      },
      "after": "81d1e43a7015e55e",
      "date": 1456068279540
    },
    {
      "type": "add",
      "id": "81d1e43a7015e55e",
      "item": {
        "type": "paragraph",
        "id": "81d1e43a7015e55e",
        "text": "Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out."
      },
      "after": "9aff3b0f59a2e055",
      "date": 1456068270900
    },
    {
      "type": "add",
      "id": "9aff3b0f59a2e055",
      "item": {
        "type": "paragraph",
        "id": "9aff3b0f59a2e055",
        "text": "#Code"
      },
      "after": "6a2be185a37b6d3a",
      "date": 1456068252939
    },
    {
      "type": "add",
      "id": "6a2be185a37b6d3a",
      "item": {
        "type": "paragraph",
        "id": "6a2be185a37b6d3a",
        "text": "As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules."
      },
      "after": "22cddf4e9509eb02",
      "date": 1456068234466
    },
    {
      "type": "edit",
      "id": "22cddf4e9509eb02",
      "item": {
        "type": "paragraph",
        "id": "22cddf4e9509eb02",
        "text": "Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. "
      },
      "date": 1456068230491
    },
    {
      "type": "add",
      "id": "fc4f133269442c0d",
      "item": {
        "type": "paragraph",
        "id": "fc4f133269442c0d",
        "text": "It is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information)."
      },
      "after": "22cddf4e9509eb02",
      "date": 1456068222643
    },
    {
      "type": "edit",
      "id": "22cddf4e9509eb02",
      "item": {
        "type": "paragraph",
        "id": "22cddf4e9509eb02",
        "text": "Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. \nAs an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken."
      },
      "date": 1456068221390
    },
    {
      "type": "edit",
      "id": "481617af8e248dee",
      "item": {
        "type": "markdown",
        "id": "481617af8e248dee",
        "text": "# Legal"
      },
      "date": 1456068200814
    },
    {
      "type": "add",
      "id": "481617af8e248dee",
      "item": {
        "type": "paragraph",
        "id": "481617af8e248dee",
        "text": "# Legal"
      },
      "after": "22cddf4e9509eb02",
      "date": 1456068199713
    },
    {
      "type": "edit",
      "id": "22cddf4e9509eb02",
      "item": {
        "type": "paragraph",
        "id": "22cddf4e9509eb02",
        "text": "Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. \nAs an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\n"
      },
      "date": 1456068197932
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "51f0b75e61d97634",
        "bf950a5203dbac9b",
        "ce0aa3ab34635a94",
        "f833a46eed51d551",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "22cddf4e9509eb02",
      "date": 1456068187881
    },
    {
      "type": "add",
      "id": "22cddf4e9509eb02",
      "item": {
        "type": "paragraph",
        "id": "22cddf4e9509eb02",
        "text": "ads"
      },
      "after": "8372e0d253ded1cb",
      "date": 1456068185928
    },
    {
      "type": "remove",
      "id": "74ad0246ceb07b40",
      "date": 1456068179630
    },
    {
      "type": "edit",
      "id": "74ad0246ceb07b40",
      "item": {
        "type": "markdown",
        "id": "74ad0246ceb07b40",
        "text": "Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\n# Legal"
      },
      "date": 1456068140971
    },
    {
      "type": "add",
      "id": "852287d7e1959f2d",
      "item": {
        "type": "paragraph",
        "id": "852287d7e1959f2d",
        "text": "Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions."
      },
      "after": "74ad0246ceb07b40",
      "date": 1456068139614
    },
    {
      "type": "add",
      "id": "74ad0246ceb07b40",
      "item": {
        "type": "paragraph",
        "id": "74ad0246ceb07b40",
        "text": "Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\n# Legal"
      },
      "after": "1170e9df814a97db",
      "date": 1456068128545
    },
    {
      "type": "edit",
      "id": "1170e9df814a97db",
      "item": {
        "type": "markdown",
        "id": "1170e9df814a97db",
        "text": "# Proof -> Crypto"
      },
      "date": 1456068034734
    },
    {
      "type": "add",
      "id": "1170e9df814a97db",
      "item": {
        "type": "paragraph",
        "id": "1170e9df814a97db",
        "text": "# Proof -> Crypto"
      },
      "after": "8372e0d253ded1cb",
      "date": 1456068033556
    },
    {
      "type": "edit",
      "id": "8372e0d253ded1cb",
      "item": {
        "type": "paragraph",
        "id": "8372e0d253ded1cb",
        "text": "A logical proof is a proof within a formal system of logic, as used regularly in math."
      },
      "date": 1456068021238
    },
    {
      "type": "add",
      "id": "4fb4b1f45bfab7b8",
      "item": {
        "type": "paragraph",
        "id": "4fb4b1f45bfab7b8",
        "text": "The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof [[Type Theory]] literature for more information."
      },
      "after": "a5fd8f7d06f688af",
      "date": 1456068002750
    },
    {
      "type": "add",
      "id": "a5fd8f7d06f688af",
      "item": {
        "type": "paragraph",
        "id": "a5fd8f7d06f688af",
        "text": "A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. "
      },
      "after": "20fa7497b8be6ca1",
      "date": 1456067989556
    },
    {
      "type": "edit",
      "id": "20fa7497b8be6ca1",
      "item": {
        "type": "paragraph",
        "id": "20fa7497b8be6ca1",
        "text": "A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. "
      },
      "date": 1456067987428
    },
    {
      "type": "edit",
      "id": "8dd745ba93273d44",
      "item": {
        "type": "markdown",
        "id": "8dd745ba93273d44",
        "text": "# DHT -> Blockchain"
      },
      "date": 1456067977436
    },
    {
      "type": "edit",
      "id": "019c471e9bb534b1",
      "item": {
        "type": "markdown",
        "id": "019c471e9bb534b1",
        "text": "# Proof -> Logic"
      },
      "date": 1456067971566
    },
    {
      "type": "edit",
      "id": "019c471e9bb534b1",
      "item": {
        "type": "paragraph",
        "id": "019c471e9bb534b1",
        "text": "# Proof -> Logic"
      },
      "date": 1456067970179
    },
    {
      "type": "add",
      "id": "8372e0d253ded1cb",
      "item": {
        "type": "paragraph",
        "id": "8372e0d253ded1cb",
        "text": "A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions."
      },
      "after": "019c471e9bb534b1",
      "date": 1456067961234
    },
    {
      "type": "add",
      "id": "019c471e9bb534b1",
      "item": {
        "type": "paragraph",
        "id": "019c471e9bb534b1",
        "text": " Proof->Logic"
      },
      "after": "20fa7497b8be6ca1",
      "date": 1456067959481
    },
    {
      "type": "edit",
      "id": "14795b8532ba5515",
      "item": {
        "type": "markdown",
        "id": "14795b8532ba5515",
        "text": "# Proof"
      },
      "date": 1456067951177
    },
    {
      "type": "edit",
      "id": "8dd745ba93273d44",
      "item": {
        "type": "markdown",
        "id": "8dd745ba93273d44",
        "text": "# DHT->Blockchain"
      },
      "date": 1456067950118
    },
    {
      "type": "add",
      "id": "20fa7497b8be6ca1",
      "item": {
        "type": "paragraph",
        "id": "20fa7497b8be6ca1",
        "text": "A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information."
      },
      "after": "14795b8532ba5515",
      "date": 1456067946985
    },
    {
      "type": "add",
      "id": "14795b8532ba5515",
      "item": {
        "type": "paragraph",
        "id": "14795b8532ba5515",
        "text": "# Proof"
      },
      "after": "ab4af9af9419cd04",
      "date": 1456067940584
    },
    {
      "type": "add",
      "id": "ab4af9af9419cd04",
      "item": {
        "type": "paragraph",
        "id": "ab4af9af9419cd04",
        "text": "Blockchain's form of storing and transferring the blocks is also a special case of DHT."
      },
      "after": "8dd745ba93273d44",
      "date": 1456067933312
    },
    {
      "type": "edit",
      "id": "8dd745ba93273d44",
      "item": {
        "type": "paragraph",
        "id": "8dd745ba93273d44",
        "text": "# DHT->Blockchain"
      },
      "date": 1456067930824
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "51f0b75e61d97634",
        "bf950a5203dbac9b",
        "ce0aa3ab34635a94",
        "f833a46eed51d551",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "e93401bb80e4bc10",
      "date": 1456067920012
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "51f0b75e61d97634",
        "bf950a5203dbac9b",
        "ce0aa3ab34635a94",
        "f833a46eed51d551",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "91c5253527674948",
        "e93401bb80e4bc10",
        "8dd745ba93273d44",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "8dd745ba93273d44",
      "date": 1456067901143
    },
    {
      "type": "add",
      "id": "8dd745ba93273d44",
      "item": {
        "type": "paragraph",
        "id": "8dd745ba93273d44",
        "text": "\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions."
      },
      "after": "91c5253527674948",
      "date": 1456067885680
    },
    {
      "type": "add",
      "id": "91c5253527674948",
      "item": {
        "type": "paragraph",
        "id": "91c5253527674948",
        "text": "An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below)."
      },
      "after": "2d1ee7ca108b7602",
      "date": 1456067884213
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "markdown",
        "id": "e93401bb80e4bc10",
        "text": "# Blockchain"
      },
      "date": 1456067862940
    },
    {
      "type": "edit",
      "id": "17ca8ff2255e9b2d",
      "item": {
        "type": "markdown",
        "id": "17ca8ff2255e9b2d",
        "text": "# Economy"
      },
      "date": 1456067846614
    },
    {
      "type": "add",
      "id": "55540cf839d1d7fa",
      "item": {
        "type": "paragraph",
        "id": "55540cf839d1d7fa",
        "text": "The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras - [https://github.com/naturalog/Bitagoras github]"
      },
      "after": "17ca8ff2255e9b2d",
      "date": 1456067845698
    },
    {
      "type": "edit",
      "id": "17ca8ff2255e9b2d",
      "item": {
        "type": "paragraph",
        "id": "17ca8ff2255e9b2d",
        "text": "# Economy"
      },
      "date": 1456067844457
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "markdown",
        "id": "e93401bb80e4bc10",
        "text": "Blockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions."
      },
      "date": 1456067839823
    },
    {
      "type": "add",
      "id": "17ca8ff2255e9b2d",
      "item": {
        "type": "paragraph",
        "id": "17ca8ff2255e9b2d",
        "text": "The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras - [https://github.com/naturalog/Bitagoras github]"
      },
      "after": "e93401bb80e4bc10",
      "date": 1456067805656
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "paragraph",
        "id": "e93401bb80e4bc10",
        "text": "Blockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions.\n\n# Economy"
      },
      "date": 1456067768474
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "markdown",
        "id": "e93401bb80e4bc10",
        "text": "Blockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions.\n\n# Economy"
      },
      "date": 1456067769598
    },
    {
      "type": "edit",
      "id": "e77247e736149821",
      "item": {
        "type": "markdown",
        "id": "e77247e736149821",
        "text": "# Information"
      },
      "date": 1456067755369
    },
    {
      "type": "add",
      "id": "e77247e736149821",
      "item": {
        "type": "paragraph",
        "id": "e77247e736149821",
        "text": "# Information"
      },
      "after": "e93401bb80e4bc10",
      "date": 1456067754460
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "paragraph",
        "id": "e93401bb80e4bc10",
        "text": "Blockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions.\n\nEconomy: The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras (https://github.com/naturalog/Bitagoras).\n\n"
      },
      "date": 1456067753024
    },
    {
      "type": "add",
      "id": "fef89757a5e4b418",
      "item": {
        "type": "paragraph",
        "id": "fef89757a5e4b418",
        "text": "Even with not-so-many users, Tau network will be able to download virtually the whole internet, practically giving everyone the same information Google has, and more: data can be queried and processed more meaningfully and collaboratively, so you could perform queries as you like. Imagine how your search would look like if you had the whole of Google's database! The futuristic search engine I've been talking about the past year is going to take place over Tau."
      },
      "after": "e93401bb80e4bc10",
      "date": 1456067747148
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "paragraph",
        "id": "e93401bb80e4bc10",
        "text": "Blockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions.\n\nEconomy: The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras (https://github.com/naturalog/Bitagoras).\n\nInformation"
      },
      "date": 1456067745657
    },
    {
      "type": "add",
      "id": "7ebf3780b45fe179",
      "item": {
        "type": "paragraph",
        "id": "7ebf3780b45fe179",
        "text": "Another example of a nontrivial usage is the ability to find implications across sciences: one math problem might be isomorphic to some chemistry problem, and such correspondence can be easily detected and used over Tau.\n\nFor more information please see:\nhttp://www.idni.org/blog\nhttp://tauchain.org/tauchain.pdf"
      },
      "after": "e93401bb80e4bc10",
      "date": 1456067738482
    },
    {
      "type": "edit",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "paragraph",
        "id": "e93401bb80e4bc10",
        "text": "Blockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions.\n\nEconomy: The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras (https://github.com/naturalog/Bitagoras).\n\nInformation: Even with not-so-many users, Tau network will be able to download virtually the whole internet, practically giving everyone the same information Google has, and more: data can be queried and processed more meaningfully and collaboratively, so you could perform queries as you like. Imagine how your search would look like if you had the whole of Google's database! The futuristic search engine I've been talking about the past year is going to take place over Tau."
      },
      "date": 1456067737071
    },
    {
      "type": "edit",
      "id": "4e8580b94f794329",
      "item": {
        "type": "markdown",
        "id": "4e8580b94f794329",
        "text": "# Kademlia -> Bittorrent"
      },
      "date": 1456067722962
    },
    {
      "type": "edit",
      "id": "0ccc2d8a5d959355",
      "item": {
        "type": "markdown",
        "id": "0ccc2d8a5d959355",
        "text": "# DHT -> Kademlia"
      },
      "date": 1456067717178
    },
    {
      "type": "add",
      "id": "b5780e80e88bc893",
      "item": {
        "type": "paragraph",
        "id": "b5780e80e88bc893",
        "text": "A DHT is a general scheme for decentralized file storage. Every file has a unique identifier (hash) and is retrieved by it."
      },
      "after": "cce4ec4638cbdae8",
      "date": 1456067696959
    },
    {
      "type": "edit",
      "id": "cce4ec4638cbdae8",
      "item": {
        "type": "markdown",
        "id": "cce4ec4638cbdae8",
        "text": "# DHT (Distributed Hash Tables)"
      },
      "date": 1456067683034
    },
    {
      "type": "edit",
      "id": "cce4ec4638cbdae8",
      "item": {
        "type": "paragraph",
        "id": "cce4ec4638cbdae8",
        "text": "# DHT (Distributed Hash Tables)"
      },
      "date": 1456067681380
    },
    {
      "type": "add",
      "id": "e93401bb80e4bc10",
      "item": {
        "type": "paragraph",
        "id": "e93401bb80e4bc10",
        "text": "\nBlockchain: An algorithm for decentralized timestamping, meaning nodes may agree about the chronological order of events without having to trust each other. A blockchain is a chain of blocks, where the next block is accepted by the nodes only if it meets certain cryptographic requirements that imply time ordering (under cryptographic assumptions, briefly described below).\n\nDHT->Blockchain: Blockchain's form of storing and transferring the blocks is also a special case of DHT.\n\nProof: A notion of proof comes in some formal system. A formal system consists of an alphabet and rules how terms may be formed using this alphabet. In Euclidean geometry, for example, we have a formal system consists of logic and Euclid's axioms. A proof of a term (or statement, or theorem) is a sequence of terms that reaches from the given term to some of the axioms, where every step has to be justified by a derivation rule. The most natural derivation rule is called modus ponens, which says that if A⇒B (A implies B), and A is true, then B is true. This derivation rule can be expressed formally as ((A⇒B) & A)⇒B. Though the perceptive reader might feel some kind of cyclicity on this definition, that touches on the difference between judgements and rules. Refer to Martin-Lof Type Theory literature for more information.\n\nProof->Logic: A logical proof is a proof within a formal system of logic, as used regularly in math.\n\nProof->Crypto: Some proofs are not proofs in the logical sense, but it is customary to accept them as proofs for practical uses. A proof under cryptographic assumptions generally means two things: that we agree on some lower bound of human ability (like algorithms that perform more than 10^86 steps therefore can never be done by human since this is the number of atoms in the whole visible universe), and we agree that some problems are indeed that hard. As an example, taking a 1MB file and hashing it into a much shorter string, will of course not generate a unique hash (due to Dirichlet's pigeonhole principle), but it is believed (and yet unproved) that generating a file with a given hash is physically impossible. It should be noted that cryptographic proofs can be used only in special cases. There is no way to cryptographically prove \"ordinary\" mathematical theorems, and they should require logical proofs as customary. Nevertheless, it should be noted that cryptographic assumptions can be considered as a part of a formal system, since they indeed define inference rules.\n\nCode: Any programming language is a formal system, and as such we may ask on its expressiveness, consistency etc. A general model for computation was first given by Turing, namely, the Turing Machine. A Turing machine is a mathematical object supplied as a set of axioms, and is believed to represent any physical computer (the Church-Turing thesis). So we apparently have maximum expressibility. Is it good? The answer is astonishingly no, and it was Turing himself who pointed it out:\n\nCode->Undecidable: Turing showed that he can derive a contradiction from the definition of his machine. He presented the following question: does there exist  Turing machine that correctly determines whether another Turing machine ever halts (i.e. not entering an infinite loop or so)? He then showed that both \"yes\" and \"no\" answers to that question derive a contradiction.\nAround that time, several such results would change what mathematicians believed for ages. I'll mention here only Godel and Russell. Godel has constructed a question that, as in the halting problem, both \"yes\" and \"no\" reach a contradiction. For that he assumed an axiomatic system of the natural numbers only, together with the four operations of arithmetic. He then proved that the notion of the natural numbers is undecidable as well! There are no words to describe the shock among the mathematical community about this discovery. Godel showed that any attempt to formalize arithmetic within a finite axiomatic system will end up either inconsistent or incomplete. By inconsistency we mean that axioms contradict each other, i.e. can prove a theorem and its negation. Completeness means that every correct theorem has a proof.\nLast example, due to its simplicity and strong connection to type theory, is Russell's paradox. Russell is, in fact, the founder of type theory. Russell asked the following question about Cantor's set theory: Let X be the set of all sets that do not contain themselves. Does X contain itself? If you say no, then it must contain itself since we defined it as the set of all sets that do not contain themselves. If you say yes, then again it turns out it must be no, since it contains only what does not contain itself. Contradiction.\nObviously, decidability bugged mathematicians and philosophers since those early 20th century discoveries. Many alternative logical systems were proposed, but the most relevant to our discussion is the Intuitionistic logic. But, in those days, it was not clear at all that intuitionism has to do with \"better\" foundations of mathematics.\nWhen computer science evolved it turned out that computer programs are exactly the proofs we were talking about: every proof is a computer program and any computer program is a proof in some formal system. This result is called the Curry-Howard correspondence.\n\nCode->Decidable: Later on during the 70s and the 80s, Per Martin-Lof made another huge step by presenting a formal system that is decidable, and when taking it through the Curry-Howard correspondence we discover it can express anything a finite Turing machine can express! He utilized the idea of Dependent Types and showed that using them we can do anything a finite (=real) computer can do, but keeping the logic decidable hence being able to prove any correct statement about a given code. For example, the halting problem is not a problem on our case: not only that the decidability property assures us that we can prove that a halting machine indeed halts, but we also have an explicit algorithm for this. It has to do with Productivity and Totality checks, and the reader is referred to the literature of Pure Functional Programming Languages for more information.\nOver the last years Martin-Lof type theory developed to be no less than a new foundation of mathematics under the codenames \"The New Foundations\" and \"HoTT (Homotopy Type Theory)\", giving rise to the development of new math with the new foundations, and this time, when the computer is a participant just like us.\n\nDecidable->Tau: Tau client contains an automated theorem prover that is compatible with Martin-Lof type theory. Every mathematical or, equivalently, programmatic statement can be proved. This allows supplying code with proofs: a proof that the code meets formal requirements or admits safety measurements. We already saw that under undecidable systems, proving \"yes\" doesn't mean we cannot prove \"no\". But under our decidable logic, we can prove exactly all true statements. Under the Curry-Howard correspondence, mathematical and logical statements (which become identical on Tau), are code in machine language and vice versa. The prover is able to reason over the code as over any other dependently-typed formal system, and either generate desired proofs or verify them.\nTaking this a step further, and employing verifiable computing architectures such as Miller's lambda-auth, we can create and verify a proof that a machine executed the steps it was expected to execute. This of course has far going implications on a decentralized and trustless environment. Tau merkle-izes the execution tree and provides a proof as in lambda-auth.\n\nUndecidable->Ethereum: As known, Ethereum's language is Turing complete, hence there is no sense of proof over a code or over their formal system, since as we saw, sometimes we can prove both \"yes\" and \"no\" as in the halting problem.\n\nContracts->Ethereum: Ethereum is designed such that all nodes execute the contracts. It does not fit uses where many nodes running exactly the same code is unneeded, hence only admits a narrow section of uses mainly at the form of programmable contracts.\n\nGeneral Purpose->Tau: Tau gives a full programming language that is designed to be general purpose even locally and not necessarily in a network. We can see why dependently typed languages (equivalently, pure functional programming languages) are important, due to their decidability on one hand, and practically maximum expressiveness on the other. Existing such languages are Agda2, Coq and Idris (the last one is general-purpose), though they are hard to learn and far from the intuitive structure of \"subject predicate object\" as in Tau. Tau takes RDF languages (like Turtle, Notation3) and gives them semantics to boost them into fully functional languages.\n\nRules->Fixed->Bitcoin/Ethereum: The protocol of the network cannot easily be changed. If, for example, we'd like to change the block time or block reward, we'll probably have to perform a hard fork. The client, as the protocol, are fixed.\n\nRules->Dynamic->Tau: Tau's client is a reasoner that can take a knowledge base and ask \"what should I do now\" (this is completely equivalent to being the automated theorem prover as above). So the client downloads its own \"directions\" from the blockchain and follows them. The current block should also specify the acceptance conditions of the next block.\n\nBlockchain->Tau, Kademlia->Tau: Tau reasoner contains builtins that let it perform DHT and blockchains operations. Rules can direct the client to perform such and hence communicate with other nodes, still trustlessly being able to authenticate both data (by DHT hash) and its time (by blockchain timestamping). It should be mentioned that Tau's logic natively supports “contexts”, meaning, there is no \"one ruleset\" - anyone can create a new context and operate separately from other ones. Still, they may reference existing contexts and reuse their code.\n\nWe have explained the chart. Now here is a bit more elaboration on Tau's features and properties:\n\nProgramming Language: Tau is the first dependently-typed programming language that is considered human-readable. We take existing languages (RDF family like NQuads, Notation3) and give them semantics to perform as a general computation language.\nIt is also the first programming language that contains a blockchain support built-in. Building a decentralized application over Tau is natively supported and is in fact Tau's goal: to generalize the concept of decentralized applications to the highest degree possible. It’s also worth mentioning that Tau is a multi-lingual programming language: ontologies can be written in English or Chinese or Russian or even a language you invented yourself, as long as it keeps the subject-predicate-object structure and aliases Tau's builtins.\n\nSoftware Development: Tau is also like a decentralized GitHub, but with far-going abilities thanks to the decidability of our type-system (which does not exist in Turing-complete languages).\nThis allows an ultimate code reuse: if you want some function or piece of code, you can formulate only the requirements of that function, and if a matching one already exists in Tau's codebase, you can easily find it and use it.\nNow what if there isn't such a function yet? Over Agoras one could set a reward to whoever implements those requirements. Because over Tau one can supply (and generate) a proof that a code is meeting requirements, the whole process does not require trust.\nTau is also like a decentralized Appstore. It allows running apps from the Tau-chain. Thanks to the type-system we're able to offer another revolutionary feature: one may choose to run apps only if they have a proof that they are safe! Since on Tau one can prove or disprove any claim regarding a given code without actually running it, various security requirements can be chosen and provably cannot be broken.\nIt is also possible to prove execution and not only requirements. One is able to supply a proof that a code was executed on their machine as expected, i.e. provable/verifiable computing (See Miller for further information).\n\nLegal: Tau can also be seen as a decentralized and collaborative democracy and rulemaking system. This goes from formulating rules, obeying them (as long as a computer can obey such rules), and voting for them in any vote mechanism the users themselves choose. Moreover: one could query the laws with the reasoner and find conclusions and inconsistencies in a rule system. One could also supply an explanation that can be automatically validated. Hence, for example, even trustless arbitration can take place, where the arbitrators have to give a formal explanations to their decisions.\n\nEconomy: The economical implications of Tau and Agoras cannot be exaggerated. Tau is able to incentivize itself: the users can set any rule to incentivize any participant by some conditions (the simplest example would be a mining block reward, though it can be anything and can be changed with time unlike in traditional blockchain). Tau also opens the door for global computing resource market with scales of storage and general-purpose computational power never imagined. Also human services can be given over the network, as I described wrt Bitagoras (https://github.com/naturalog/Bitagoras).\n\nInformation: Even with not-so-many users, Tau network will be able to download virtually the whole internet, practically giving everyone the same information Google has, and more: data can be queried and processed more meaningfully and collaboratively, so you could perform queries as you like. Imagine how your search would look like if you had the whole of Google's database! The futuristic search engine I've been talking about the past year is going to take place over Tau.\nAnother example of a nontrivial usage is the ability to find implications across sciences: one math problem might be isomorphic to some chemistry problem, and such correspondence can be easily detected and used over Tau.\n\nFor more information please see:\nhttp://www.idni.org/blog\nhttp://tauchain.org/tauchain.pdf"
      },
      "after": "2d1ee7ca108b7602",
      "date": 1456067662860
    },
    {
      "type": "add",
      "id": "2d1ee7ca108b7602",
      "item": {
        "type": "paragraph",
        "id": "2d1ee7ca108b7602",
        "text": "[[Bittorrent]] is a special case of Kademlia and is the most successful and popular decentralized file sharing network nowadays."
      },
      "after": "4e8580b94f794329",
      "date": 1456067658324
    },
    {
      "type": "edit",
      "id": "4e8580b94f794329",
      "item": {
        "type": "markdown",
        "id": "4e8580b94f794329",
        "text": "# Kademlia->Bittorrent"
      },
      "date": 1456067653167
    },
    {
      "type": "add",
      "id": "4e8580b94f794329",
      "item": {
        "type": "paragraph",
        "id": "4e8580b94f794329",
        "text": "# Kademlia->Bittorrent"
      },
      "after": "566e3d6efc3b587c",
      "date": 1456067644618
    },
    {
      "type": "add",
      "id": "566e3d6efc3b587c",
      "item": {
        "type": "paragraph",
        "id": "566e3d6efc3b587c",
        "text": "[[Kademlia]] is a special case of [[DHT]] using the cryptographic hash SHA1 and uses an efficient metric (the XOR metric) that significantly speeds up the process of finding a node storing a file given its hash."
      },
      "after": "0ccc2d8a5d959355",
      "date": 1456067629521
    },
    {
      "type": "edit",
      "id": "0ccc2d8a5d959355",
      "item": {
        "type": "markdown",
        "id": "0ccc2d8a5d959355",
        "text": "# DHT->Kademlia"
      },
      "date": 1456067617176
    },
    {
      "type": "add",
      "id": "0ccc2d8a5d959355",
      "item": {
        "type": "paragraph",
        "id": "0ccc2d8a5d959355",
        "text": "# DHT->Kademlia"
      },
      "after": "cce4ec4638cbdae8",
      "date": 1456067615273
    },
    {
      "type": "edit",
      "id": "cce4ec4638cbdae8",
      "item": {
        "type": "paragraph",
        "id": "cce4ec4638cbdae8",
        "text": "[[DHT]] (Distributed Hash Tables): A general scheme for decentralized file storage. Every file has a unique identifier (hash) and is retrieved by it."
      },
      "date": 1456067578311
    },
    {
      "item": {
        "type": "factory",
        "id": "cce4ec4638cbdae8"
      },
      "id": "cce4ec4638cbdae8",
      "type": "add",
      "after": "f833a46eed51d551",
      "date": 1456067559731
    },
    {
      "type": "edit",
      "id": "f833a46eed51d551",
      "item": {
        "type": "image",
        "id": "f833a46eed51d551",
        "url": "data:image/jpeg;base64,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ef8AXUf+gLTbmdoQm1VLMT95toGAT1/CnSB4by53RSlZHDqyIWBG0Dt7g012SRdslvK464aBj/StE9CGtSrJq8KfwSEDknjp2PXvV2GUTRLIoIDDoRgioisJOTaSHkn/AI9279e1PWQKoVYJgo4AEDcfpRcVhEmMOo/JDJKzRcBAPXuTgCre2+m+/JHbL6Rje35ngfkaisVd7x5jG6RhAgLrtLHOTwefT860ah7lrYqx2FujiR1Msg6PKdxH0z0/CrNLRSGFFFFABRRRQAUUUUAFFFFABUc0Mc8ZjlQMp7H+dSUUAZOoi4ttPuI2zcQNGQG/jT6+o9+v161LVm/ieaxnijGXaMhR6nFUhMSOYLgH0MLcfpVRJkVP7TVbiSOSMqq7sMM87c+o9j0Joh1aGUouyQFiq5xwCff68VYfynGHtZGHvbsf6UmId277JJnIOfs7dR07VVybFiptL/5Btv8A7gqqZuP9TcH/ALYt/hV3T43hsYI5BtcINw9D6VMioliiiipKCiikoAWiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Z",
        "caption": "Uploaded image",
        "text": "Uploaded image"
      },
      "date": 1456067425566
    },
    {
      "item": {
        "type": "factory",
        "id": "f833a46eed51d551"
      },
      "id": "f833a46eed51d551",
      "type": "add",
      "after": "ce0aa3ab34635a94",
      "date": 1456067393957
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "51f0b75e61d97634",
        "bf950a5203dbac9b",
        "ce0aa3ab34635a94"
      ],
      "id": "51f0b75e61d97634",
      "date": 1456066968302
    },
    {
      "type": "remove",
      "id": "a758d9cf991bca30",
      "date": 1456066963148
    },
    {
      "type": "edit",
      "id": "a758d9cf991bca30",
      "item": {
        "type": "code",
        "id": "a758d9cf991bca30",
        "text": "If law-making is a game, then it is a game in which changing the rules is a move. - Peter Suber presenting [[Nomic]]."
      },
      "date": 1456066959688
    },
    {
      "type": "edit",
      "id": "51f0b75e61d97634",
      "item": {
        "type": "paragraph",
        "id": "51f0b75e61d97634",
        "text": "If law-making is a game, then it is a game in which changing the rules is a move. - [[Peter Suber]] presenting [[Nomic]]."
      },
      "date": 1456066945973
    },
    {
      "item": {
        "type": "factory",
        "id": "51f0b75e61d97634"
      },
      "id": "51f0b75e61d97634",
      "type": "add",
      "after": "a758d9cf991bca30",
      "date": 1456066920718
    },
    {
      "type": "edit",
      "id": "a758d9cf991bca30",
      "item": {
        "type": "code",
        "id": "a758d9cf991bca30",
        "text": "If law-making is a game, then it is a game in which changing the rules is a move. - Peter Suber presenting Nomic."
      },
      "date": 1456066901418
    },
    {
      "item": {
        "type": "factory",
        "id": "a758d9cf991bca30"
      },
      "id": "a758d9cf991bca30",
      "type": "add",
      "after": "ce0aa3ab34635a94",
      "date": 1456066879375
    },
    {
      "type": "edit",
      "id": "deb7edfb7ebedf00",
      "item": {
        "type": "paragraph",
        "id": "deb7edfb7ebedf00",
        "text": "τ-chain (pronounced tau-chain) is a decentralized peer-to-peer network having three unified faces: Rules, Proofs, and Computer Programs, allowing a generalization of virtually any centralized or decentralized P2P network, together with many new abilities, as we present on this note."
      },
      "date": 1456066876079
    },
    {
      "type": "add",
      "id": "bf950a5203dbac9b",
      "item": {
        "type": "paragraph",
        "id": "bf950a5203dbac9b",
        "text": "Tau chain on [http://cointelegraph.com/news/tau-chain-a-decentralized-app-store-with-greater-flexibility-than-ethereum cointelegraph.com]"
      },
      "after": "deb7edfb7ebedf00",
      "date": 1456066850765
    },
    {
      "type": "edit",
      "id": "deb7edfb7ebedf00",
      "item": {
        "type": "paragraph",
        "id": "deb7edfb7ebedf00",
        "text": "Abstract. τ-chain (pronounced tau-chain) is a decentralized peer-to-peer\nnetwork having three unified faces: Rules, Proofs, and Computer Programs,\nallowing a generalization of virtually any centralized or decentralized P2P network,\ntogether with many new abilities, as we present on this note.\n“If law-making is a game, then it is a game in which changing the\nrules is a move.” - Peter Suber presenting Nomic [10]."
      },
      "date": 1456066848478
    },
    {
      "type": "edit",
      "id": "ce0aa3ab34635a94",
      "item": {
        "type": "video",
        "id": "ce0aa3ab34635a94",
        "text": "YOUTUBE 3ORpi2MMJrA\nInterview with Ohad Asor of [[Tau Chain]]. Tau-chain is a fully decentralized P2P network being a generalization of many centralized and decentralized P2P networks, including the [[Blockchain]]."
      },
      "date": 1456066648463
    },
    {
      "type": "edit",
      "id": "ce0aa3ab34635a94",
      "item": {
        "type": "video",
        "id": "ce0aa3ab34635a94",
        "text": "YOUTUBE 3ORpi2MMJrA\n(double-click to edit caption)\n"
      },
      "date": 1456066607579
    },
    {
      "item": {
        "type": "factory",
        "id": "ce0aa3ab34635a94"
      },
      "id": "ce0aa3ab34635a94",
      "type": "add",
      "after": "deb7edfb7ebedf00",
      "date": 1456066596738
    },
    {
      "type": "edit",
      "id": "deb7edfb7ebedf00",
      "item": {
        "type": "paragraph",
        "id": "deb7edfb7ebedf00",
        "text": "Tau chain on [http://cointelegraph.com/news/tau-chain-a-decentralized-app-store-with-greater-flexibility-than-ethereum cointelegraph.com]"
      },
      "date": 1456066202107
    },
    {
      "item": {
        "type": "factory",
        "id": "deb7edfb7ebedf00"
      },
      "id": "deb7edfb7ebedf00",
      "type": "add",
      "date": 1456066179423
    },
    {
      "type": "create",
      "item": {
        "title": "Tau Chain",
        "story": []
      },
      "date": 1456066177973
    },
    {
      "type": "add",
      "item": {
        "type": "factory",
        "id": "ddd3af2191cb04a9"
      },
      "after": "51f0b75e61d97634",
      "id": "ddd3af2191cb04a9",
      "date": 1463756862134
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "01453e080a2b67b2",
        "51f0b75e61d97634",
        "003959783fc33402",
        "ddd3af2191cb04a9",
        "cce4ec4638cbdae8",
        "b5780e80e88bc893",
        "0ccc2d8a5d959355",
        "f833a46eed51d551",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "862dbbe04057d297",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "9a9ef803eabe12ec",
        "c9976459453b3b6a",
        "3f81fc6fac43608f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "003959783fc33402",
      "date": 1463756864682
    },
    {
      "type": "edit",
      "id": "ddd3af2191cb04a9",
      "item": {
        "type": "video",
        "id": "ddd3af2191cb04a9",
        "text": "YOUTUBE 6G8mTCtv8d8\nOn this talk Ohad will explain about Zennet together with Q&A - [http://zennet.sc zennet.sc]"
      },
      "date": 1463756874885
    },
    {
      "type": "edit",
      "id": "ddd3af2191cb04a9",
      "item": {
        "type": "video",
        "id": "ddd3af2191cb04a9",
        "text": "YOUTUBE 6G8mTCtv8d8\nOn this talk Ohad will explain about Zennet together with Q&A - [http://zennet.sc zennet.sc]"
      },
      "date": 1463756941241
    },
    {
      "type": "edit",
      "id": "b5780e80e88bc893",
      "item": {
        "type": "paragraph",
        "id": "b5780e80e88bc893",
        "text": "And here on [https://soundcloud.com/mindtomatter/ltb-e261-understanding-tauchains soundcloud]"
      },
      "date": 1463758435044
    },
    {
      "type": "move",
      "order": [
        "deb7edfb7ebedf00",
        "ce0aa3ab34635a94",
        "01453e080a2b67b2",
        "51f0b75e61d97634",
        "003959783fc33402",
        "ddd3af2191cb04a9",
        "b5780e80e88bc893",
        "cce4ec4638cbdae8",
        "43f7bfd5790ce4e7",
        "0ccc2d8a5d959355",
        "f833a46eed51d551",
        "566e3d6efc3b587c",
        "4e8580b94f794329",
        "2d1ee7ca108b7602",
        "e93401bb80e4bc10",
        "91c5253527674948",
        "8dd745ba93273d44",
        "ab4af9af9419cd04",
        "14795b8532ba5515",
        "20fa7497b8be6ca1",
        "a5fd8f7d06f688af",
        "4fb4b1f45bfab7b8",
        "019c471e9bb534b1",
        "8372e0d253ded1cb",
        "1170e9df814a97db",
        "22cddf4e9509eb02",
        "6a2be185a37b6d3a",
        "9aff3b0f59a2e055",
        "81d1e43a7015e55e",
        "862dbbe04057d297",
        "e1dba67ab39e8191",
        "0b2e53cf0f23eb6f",
        "9a9ef803eabe12ec",
        "c9976459453b3b6a",
        "3f81fc6fac43608f",
        "848d8ad478bd25c2",
        "5fd04b10c949eaff",
        "a813ab831ae0c2b7",
        "2afa86e3fbb39e3f",
        "df4d522f98b03600",
        "ee5513276bb0275a",
        "6cad14e2c936dbd1",
        "bac1179d5e08ade6",
        "64176451f49e1cbe",
        "33a41498c62a9691",
        "910fe8de6cbddecf",
        "dba48b80dfbca97f",
        "d40b46c0973b1280",
        "2b1b149e797aa9b8",
        "7b3750491133f8d2",
        "17bbb3e729a161c6",
        "91ab4927eb9b2bdc",
        "29117ae8363c71be",
        "be6e4fa9d2082ddd",
        "d391535bf07afa64",
        "3ed743bed259d465",
        "a5a43672d2b2991b",
        "bf77ffaf642b29b8",
        "5e1e004315c97fa9",
        "b45ca24151f74af2",
        "576d17bc62bd5f96",
        "f6e38934ec3e67c7",
        "c52c6e3a97530eee",
        "e988613869acb4a7",
        "fc4f133269442c0d",
        "481617af8e248dee",
        "852287d7e1959f2d",
        "17ca8ff2255e9b2d",
        "55540cf839d1d7fa",
        "e77247e736149821",
        "fef89757a5e4b418",
        "7ebf3780b45fe179"
      ],
      "id": "b5780e80e88bc893",
      "date": 1463758438126,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "add",
      "id": "43f7bfd5790ce4e7",
      "item": {
        "type": "paragraph",
        "id": "43f7bfd5790ce4e7",
        "text": "A DHT is a general scheme for decentralized file storage. Every file has a unique identifier (hash) and is retrieved by it."
      },
      "after": "b5780e80e88bc893",
      "date": 1463758439291
    },
    {
      "type": "fork",
      "date": 1463758446290
    },
    {
      "type": "edit",
      "id": "7ebf3780b45fe179",
      "item": {
        "type": "paragraph",
        "id": "7ebf3780b45fe179",
        "text": "Another example of a nontrivial usage is the ability to find implications across sciences: one math problem might be isomorphic to some chemistry problem, and such correspondence can be easily detected and used over Tau."
      },
      "date": 1463909153033
    },
    {
      "type": "add",
      "id": "decf307cf124dac3",
      "item": {
        "type": "paragraph",
        "id": "decf307cf124dac3",
        "text": "For more information please see:\n[http://www.idni.org/blog idni.org] or \n[http://tauchain.org/tauchain.pdf tauchain.org]"
      },
      "after": "deb7edfb7ebedf00",
      "date": 1463909184561
    },
    {
      "type": "edit",
      "id": "decf307cf124dac3",
      "item": {
        "type": "paragraph",
        "id": "decf307cf124dac3",
        "text": "For more information see:\n[http://www.idni.org/blog idni.org] or \n[http://tauchain.org/tauchain.pdf tauchain.org]"
      },
      "date": 1463909189967
    },
    {
      "type": "add",
      "id": "2f8a4e6657c92236",
      "item": {
        "type": "paragraph",
        "id": "2f8a4e6657c92236",
        "text": "# See also"
      },
      "after": "deb7edfb7ebedf00",
      "date": 1470588383054
    },
    {
      "type": "edit",
      "id": "2f8a4e6657c92236",
      "item": {
        "type": "markdown",
        "id": "2f8a4e6657c92236",
        "text": "# See also"
      },
      "date": 1470588384100
    },
    {
      "type": "edit",
      "id": "2f8a4e6657c92236",
      "item": {
        "type": "markdown",
        "id": "2f8a4e6657c92236",
        "text": "# See also\n\n* [[The DAO Hack]]\n* [["
      },
      "date": 1470588414225
    },
    {
      "type": "edit",
      "id": "2f8a4e6657c92236",
      "item": {
        "type": "markdown",
        "id": "2f8a4e6657c92236",
        "text": "# See also\n\n* [[The DAO Hack]]\n* [[DAO Private Keys]]"
      },
      "date": 1470588445392
    },
    {
      "type": "edit",
      "id": "2f8a4e6657c92236",
      "item": {
        "type": "markdown",
        "id": "2f8a4e6657c92236",
        "text": "# See also\n\n* [[The DAO Hack]]\n* [[DAO Private Keys]]\n* [[Multisigs Can't Secure DAO Keys]]\n* [[DAO Design Jam]]"
      },
      "date": 1470588502924
    }
  ]
}