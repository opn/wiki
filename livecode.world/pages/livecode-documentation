{
  "title": "Livecode Documentation",
  "story": [
    {
      "type": "paragraph",
      "id": "deb2dfe89ff080ac",
      "text": "This site is for [[Livecode]] documentation."
    },
    {
      "type": "paragraph",
      "id": "f6d260f777ac7595",
      "text": "Here we provide a [[Creative Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and [[free culture]] licensed -[http://creativecommons.org/licenses/by-sa/4.0/ creativecommons.org]"
    },
    {
      "type": "paragraph",
      "id": "b0286bf1bcfbec0c",
      "text": "For specific markup for elements of Livecode you may wish to take a look at [[Handler Documentation]]"
    },
    {
      "type": "reference",
      "id": "e1f758d698f32676",
      "site": "docs.livecode.world",
      "slug": "handler-documentation",
      "title": "Handler Documentation",
      "text": "Here is an example of how to document a Live Code [[Handler]]. See [[LiveCode Documentation Format Reference]] for further information."
    },
    {
      "type": "markdown",
      "id": "356e2e1466f9ce98",
      "text": "# From the Mothership"
    },
    {
      "type": "paragraph",
      "id": "46d1298e8d335d82",
      "text": "Currently the dictionary files are in XML, which means they are rather opaquely swathed in tags. Some of these tags are meant to be rendered directly as HTML, while others are merely structural markings - [https://livecode.com/documentation-documentation-documentation/ livecode.com]"
    },
    {
      "type": "paragraph",
      "id": "6cac0390107d687c",
      "text": " Indeed, some of the older dictionary files contain extremely convoluted passages such as the following:"
    },
    {
      "type": "code",
      "id": "d7b7cdc2ae1feefc",
      "text": "<description>Use the <b>accept</b> <glossary tag=\"command\">command</glossary> when running a <glossary tag=\"server\">server</glossary>, to accept <glossary tag=\"TCP\">TCP</glossary> connections or <glossary tag=\"UDP\">...\n\n</description>"
    },
    {
      "type": "paragraph",
      "id": "118e97c13345fc22",
      "text": "…which can’t really be easily understood without, for example, displaying in a browser, or a field using the htmltext property. All of which makes it rather difficult to read and edit, and somewhat fragile too. So I spent some time recently thinking about how we could make dictionary files that are readable, extensible, and easy to adjust. Here is an example of the proposed format, again for the accept command:"
    },
    {
      "type": "code",
      "id": "dc604071efe243b0",
      "text": "Name: accept\nType: command\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \nSummary: Accepts an internet connection and creates a <socket> for that connection."
    },
    {
      "type": "reference",
      "id": "db0c39f6ef40e6c4",
      "site": "docs.livecode.world",
      "slug": "highlightjs",
      "title": "highlight.js",
      "text": "[[Ali Lloyd]] created a LiveCode [[highlight.js]] build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image - [https://github.com/livecode/livecode-ide/blob/develop/Documentation/html_viewer/js/highlight.pack.js github]"
    },
    {
      "type": "paragraph",
      "id": "93279d0744ea69a3",
      "text": "Much of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible."
    },
    {
      "url": "http://livecode.com/wp-content/uploads/2015/01/AcceptEntry-1.png",
      "text": "Transported image. [http://livecode.com/wp-content/uploads/2015/01/AcceptEntry-1.png source]",
      "type": "image",
      "id": "d319ed316b234700"
    },
    {
      "type": "paragraph",
      "id": "2bd874573c68b158",
      "text": "Another important step we are taking is to include a table in every object’s dictionary entry, containing all of the messages and properties associated with that object. Here, for example is a snippet of how the image object’s new entry would look:"
    },
    {
      "type": "paragraph",
      "id": "4ce61c92cb74d537",
      "text": "Let me know your thoughts in the comments."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Livecode Documentation",
        "story": []
      },
      "date": 1448905540044
    },
    {
      "item": {
        "type": "factory",
        "id": "deb2dfe89ff080ac"
      },
      "id": "deb2dfe89ff080ac",
      "type": "add",
      "date": 1448905552546
    },
    {
      "type": "edit",
      "id": "deb2dfe89ff080ac",
      "item": {
        "type": "paragraph",
        "id": "deb2dfe89ff080ac",
        "text": "This site is for [[Livecode]] documentation. Here we provide a [[Create Commons"
      },
      "date": 1448978567343
    },
    {
      "type": "edit",
      "id": "deb2dfe89ff080ac",
      "item": {
        "type": "paragraph",
        "id": "deb2dfe89ff080ac",
        "text": "This site is for [[Livecode]] documentation. Here we provide a [[Create Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and licensed [fads CC BY-SA 4.0]"
      },
      "date": 1448978695570
    },
    {
      "type": "edit",
      "id": "deb2dfe89ff080ac",
      "item": {
        "type": "paragraph",
        "id": "deb2dfe89ff080ac",
        "text": "This site is for [[Livecode]] documentation. Here we provide a [[Create Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and licensed [http://creativecommons.org/licenses/by-sa/4.0/ CC BY-SA 4.0]"
      },
      "date": 1448978713565
    },
    {
      "type": "edit",
      "id": "deb2dfe89ff080ac",
      "item": {
        "type": "paragraph",
        "id": "deb2dfe89ff080ac",
        "text": "This site is for [[Livecode]] documentation."
      },
      "date": 1448978733900
    },
    {
      "type": "add",
      "id": "f6d260f777ac7595",
      "item": {
        "type": "paragraph",
        "id": "f6d260f777ac7595",
        "text": "Here we provide a [[Create Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and licensed [http://creativecommons.org/licenses/by-sa/4.0/ CC BY-SA 4.0]"
      },
      "after": "deb2dfe89ff080ac",
      "date": 1448978735564
    },
    {
      "item": {
        "type": "factory",
        "id": "356e2e1466f9ce98"
      },
      "id": "356e2e1466f9ce98",
      "type": "add",
      "after": "f6d260f777ac7595",
      "date": 1458310738617
    },
    {
      "type": "edit",
      "id": "356e2e1466f9ce98",
      "item": {
        "type": "paragraph",
        "id": "356e2e1466f9ce98",
        "text": "# from the Mothership"
      },
      "date": 1458310870255
    },
    {
      "type": "add",
      "id": "46d1298e8d335d82",
      "item": {
        "type": "paragraph",
        "id": "46d1298e8d335d82",
        "text": "Currently the dictionary files are in XML, which means they are rather opaquely swathed in tags. Some of these tags are meant to be rendered directly as HTML, while others are merely structural markings. Indeed, some of the older dictionary files contain extremely convoluted passages such as the following:\n\n<description>Use the <b>accept</b> <glossary tag=\"command\">command</glossary> when running a <glossary tag=\"server\">server</glossary>, to accept <glossary tag=\"TCP\">TCP</glossary> connections or <glossary tag=\"UDP\">UDP</glossary> <glossary tag=\"datagram\">datagrams</glossary> from other systems (or other <glossary tag=\"process\">processes</glossary> on the same system).<p>Use the datagram option if you want to accept UDP datagrams.</p><p></p><p><b>Parameters:</b></p><p>The <i>portNumber</i> is the <glossary tag=\"TCP\">TCP</glossary> <glossary tag=\"port\">port</glossary> number on which to accept connections.</p><p>The <i>callbackMessage</i> is the name of a <keyword tag=\"message box\">message</keyword> to be sent when a connection is made or a <glossary tag=\"datagram\">datagram</glossary> is received.</p><p></p><p><b>Comments:</b></p><p>When a connection is made or a datagram is received, the <b>accept</b> <glossary tag=\"command\">command</glossary> creates a new <glossary tag=\"socket\">socket</glossary> that can be used to communicate with the other system (or <glossary tag=\"process\">process</glossary>). When using the <command tag=\"close socket\">close socket</command>, <command tag=\"read from socket\">read from socket</command>, or <command tag=\"write to socket\">write to socket</command> <glossary tag=\"command\">commands</glossary>, you can refer to this <glossary tag=\"socket\">socket</glossary> with a socket identifier that looks like this:</p><p><i>host</i>:<i>port</i>[|<i>connectionID</i>]</p><p>where the <i>connectionID</i> is a number assigned by the <b>accept</b> <glossary tag=\"command\">command</glossary>. (You only need to specify the connection number if there is more than one <glossary tag=\"socket\">socket</glossary> connected to a particular <glossary tag=\"port\">port</glossary> and <glossary tag=\"disabled\">host</glossary>.)</p><p></p><p>The <i>callbackMessage</i> is sent to the <glossary tag=\"object\">object</glossary> whose <property tag=\"script\">script</property> contains the <b>accept</b> <glossary tag=\"command\">command</glossary>. Either one or two <glossary tag=\"parameter\">parameters</glossary> are sent with this <keyword tag=\"message box\">message</keyword>. The first <glossary tag=\"parameter\">parameter</glossary> is the <glossary tag=\"IP address\">IP address</glossary> of the system or <glossary tag=\"process\">process</glossary> making the connection. If a <glossary tag=\"datagram\">datagram</glossary> is being accepted, the second <glossary tag=\"parameter\">parameter</glossary> is the contents of the <glossary tag=\"datagram\">datagram</glossary>.</p><p></p><p>For technical information about sockets, see RFC 147 at <<u>http://www.ietf.org/rfc/rfc147.txt</u>>.</p><p>For technical information about UDP datagrams, see RFC 768 at <<u>http://www.ietf.org/rfc/rfc0768.txt</u>>.</p><p>For technical information about the numbers used to designate standard ports, see the list of port numbers at <<u>http://www.iana.org/assignments/port-numbers</u>><i>,</i> in particular the section entitled \"Well Known Port Numbers\".</p></description>\n…which can’t really be easily understood without, for example, displaying in a browser, or a field using the htmltext property. All of which makes it rather difficult to read and edit, and somewhat fragile too. So I spent some time recently thinking about how we could make dictionary files that are readable, extensible, and easy to adjust. Here is an example of the proposed format, again for the accept command:\n\nName: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0\n\nOS: mac,windows,linux\n\nPlatforms: desktop,server,web\n\nSecurity: network\n\nExample:\naccept connections on port 80 with message \"connectionMade\"\n\nExample:\naccept datagram connections on port 80 with message \"connectionMade\"\n\nExample:\non mouseUp\n   accept connections on port 80 with message \"connectionMade\"\nend mouseUp\n\non connectionMade pIPAddress\n   put \"Connection made:\" && pIPAddress\nend connectionMade\n\nParameters:\nnumber: \ncallbackMessage: The name of a message to be sent when a connection is made or a datagram is received.\nportNumber: The TCP port number on which to accept connections.\n\nDescription:\nUse the <accept> <command> when running a <server>, to accept <TCP> connections or <UDP> <datagram|datagrams> from other systems (or other <process|processes> on the same system).\nUse the datagram option if you want to accept UDP datagrams.\n\nWhen a connection is made or a datagram is received, the <accept> <command> creates a new <socket> that can be used to communicate with the other system (or <process>). When using the <close socket>, <read from socket>, or <write to socket> <command|commands>, you can refer to this <socket> with a socket identifier that looks like this:\nhost:port[|connectionID]\nwhere the connectionID is a number assigned by the <accept> <command>. (You only need to specify the connection number if there is more than one <socket> connected to a particular <port> and <host>.)\n\nThe <callbackMessage> is sent to the <object> whose <script> contains the <accept> <command>. Either one or two <parameter|parameters> are sent with this <message>. The first <parameter> is the <IP address> of the system or <process> making the connection. If a <datagram> is being accepted, the second <parameter> is the contents of the <datagram>.\n\nFor technical information about sockets, see RFC 147 at http://www.ietf.org/rfc/rfc147.txt.\nFor technical information about UDP datagrams, see RFC 768 at http://www.ietf.org/rfc/rfc0768.txt.\nFor technical information about the numbers used to designate standard ports, see the list of port numbers at http://www.iana.org/assignments/port-numbers, in particular the section entitled \"Well Known Port Numbers\".\n\nReferences: HTTPProxy (property), script (property), read from socket (command), write to socket (command), close socket (command), open socket (command), openSockets (function), hostAddressToName (function), hostName (function), hostAddress (function), peerAddress (function), hostNameToAddress (function), datagram (glossary), IP address (glossary), TCP (glossary), port (glossary), command (glossary), socket (glossary), UDP (glossary), host (glossary), server (glossary), message (glossary), parameter (glossary), process (glossary), object (object)\n\nTags: networking\nThere are really only two syntactic features of this docs format. The first is element specification, which is just done using a colon, e.g. Name: or Type:. The second is a general linking markup – enclosing text in < and >. Hopefully you’ll agree that the latter is much more legible, and editable to boot. Moreover, it points up an inconsistency in the original file, namely that there is a variable called ‘number’ specified by the syntax, but the associated parameter being described is ‘portNumber’. Converting the xml files into this new format has uncovered all of these inconsistencies.\n\nThe idea is that when we are building a new version of LiveCode, these docs files are parsed into an array which can be displayed by the dictionary in a CEF Browser object:\n\nAcceptEntry (1)\n\nI created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image.\n\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\nMuch of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible.\n\nAnother important step we are taking is to include a table in every object’s dictionary entry, containing all of the messages and properties associated with that object. Here, for example is a snippet of how the image object’s new entry would look:\n\nImageEntry\n\nLet me know your thoughts in the comments."
      },
      "after": "356e2e1466f9ce98",
      "date": 1458310871721
    },
    {
      "type": "edit",
      "id": "356e2e1466f9ce98",
      "item": {
        "type": "paragraph",
        "id": "356e2e1466f9ce98",
        "text": "# From the Mothership"
      },
      "date": 1458310874511
    },
    {
      "type": "edit",
      "id": "356e2e1466f9ce98",
      "item": {
        "type": "markdown",
        "id": "356e2e1466f9ce98",
        "text": "# From the Mothership"
      },
      "date": 1458310875637
    },
    {
      "item": {
        "type": "factory",
        "id": "d7b7cdc2ae1feefc"
      },
      "id": "d7b7cdc2ae1feefc",
      "type": "add",
      "after": "46d1298e8d335d82",
      "date": 1458310912913
    },
    {
      "type": "edit",
      "id": "46d1298e8d335d82",
      "item": {
        "type": "paragraph",
        "id": "46d1298e8d335d82",
        "text": "Currently the dictionary files are in XML, which means they are rather opaquely swathed in tags. Some of these tags are meant to be rendered directly as HTML, while others are merely structural markings. Indeed, some of the older dictionary files contain extremely convoluted passages such as the following:\n\n\n…which can’t really be easily understood without, for example, displaying in a browser, or a field using the htmltext property. All of which makes it rather difficult to read and edit, and somewhat fragile too. So I spent some time recently thinking about how we could make dictionary files that are readable, extensible, and easy to adjust. Here is an example of the proposed format, again for the accept command:\n\nName: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0\n\nOS: mac,windows,linux\n\nPlatforms: desktop,server,web\n\nSecurity: network\n\nExample:\naccept connections on port 80 with message \"connectionMade\"\n\nExample:\naccept datagram connections on port 80 with message \"connectionMade\"\n\nExample:\non mouseUp\n   accept connections on port 80 with message \"connectionMade\"\nend mouseUp\n\non connectionMade pIPAddress\n   put \"Connection made:\" && pIPAddress\nend connectionMade\n\nParameters:\nnumber: \ncallbackMessage: The name of a message to be sent when a connection is made or a datagram is received.\nportNumber: The TCP port number on which to accept connections.\n\nDescription:\nUse the <accept> <command> when running a <server>, to accept <TCP> connections or <UDP> <datagram|datagrams> from other systems (or other <process|processes> on the same system).\nUse the datagram option if you want to accept UDP datagrams.\n\nWhen a connection is made or a datagram is received, the <accept> <command> creates a new <socket> that can be used to communicate with the other system (or <process>). When using the <close socket>, <read from socket>, or <write to socket> <command|commands>, you can refer to this <socket> with a socket identifier that looks like this:\nhost:port[|connectionID]\nwhere the connectionID is a number assigned by the <accept> <command>. (You only need to specify the connection number if there is more than one <socket> connected to a particular <port> and <host>.)\n\nThe <callbackMessage> is sent to the <object> whose <script> contains the <accept> <command>. Either one or two <parameter|parameters> are sent with this <message>. The first <parameter> is the <IP address> of the system or <process> making the connection. If a <datagram> is being accepted, the second <parameter> is the contents of the <datagram>.\n\nFor technical information about sockets, see RFC 147 at http://www.ietf.org/rfc/rfc147.txt.\nFor technical information about UDP datagrams, see RFC 768 at http://www.ietf.org/rfc/rfc0768.txt.\nFor technical information about the numbers used to designate standard ports, see the list of port numbers at http://www.iana.org/assignments/port-numbers, in particular the section entitled \"Well Known Port Numbers\".\n\nReferences: HTTPProxy (property), script (property), read from socket (command), write to socket (command), close socket (command), open socket (command), openSockets (function), hostAddressToName (function), hostName (function), hostAddress (function), peerAddress (function), hostNameToAddress (function), datagram (glossary), IP address (glossary), TCP (glossary), port (glossary), command (glossary), socket (glossary), UDP (glossary), host (glossary), server (glossary), message (glossary), parameter (glossary), process (glossary), object (object)\n\nTags: networking\nThere are really only two syntactic features of this docs format. The first is element specification, which is just done using a colon, e.g. Name: or Type:. The second is a general linking markup – enclosing text in < and >. Hopefully you’ll agree that the latter is much more legible, and editable to boot. Moreover, it points up an inconsistency in the original file, namely that there is a variable called ‘number’ specified by the syntax, but the associated parameter being described is ‘portNumber’. Converting the xml files into this new format has uncovered all of these inconsistencies.\n\nThe idea is that when we are building a new version of LiveCode, these docs files are parsed into an array which can be displayed by the dictionary in a CEF Browser object:\n\nAcceptEntry (1)\n\nI created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image.\n\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\nMuch of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible.\n\nAnother important step we are taking is to include a table in every object’s dictionary entry, containing all of the messages and properties associated with that object. Here, for example is a snippet of how the image object’s new entry would look:\n\nImageEntry\n\nLet me know your thoughts in the comments."
      },
      "date": 1458310914603
    },
    {
      "type": "edit",
      "id": "d7b7cdc2ae1feefc",
      "item": {
        "type": "code",
        "id": "d7b7cdc2ae1feefc",
        "text": "<description>Use the <b>accept</b> <glossary tag=\"command\">command</glossary> when running a <glossary tag=\"server\">server</glossary>, to accept <glossary tag=\"TCP\">TCP</glossary> connections or <glossary tag=\"UDP\">UDP</glossary> <glossary tag=\"datagram\">datagrams</glossary> from other systems (or other <glossary tag=\"process\">processes</glossary> on the same system).<p>Use the datagram option if you want to accept UDP datagrams.</p><p></p><p><b>Parameters:</b></p><p>The <i>portNumber</i> is the <glossary tag=\"TCP\">TCP</glossary> <glossary tag=\"port\">port</glossary> number on which to accept connections.</p><p>The <i>callbackMessage</i> is the name of a <keyword tag=\"message box\">message</keyword> to be sent when a connection is made or a <glossary tag=\"datagram\">datagram</glossary> is received.</p><p></p><p><b>Comments:</b></p><p>When a connection is made or a datagram is received, the <b>accept</b> <glossary tag=\"command\">command</glossary> creates a new <glossary tag=\"socket\">socket</glossary> that can be used to communicate with the other system (or <glossary tag=\"process\">process</glossary>). When using the <command tag=\"close socket\">close socket</command>, <command tag=\"read from socket\">read from socket</command>, or <command tag=\"write to socket\">write to socket</command> <glossary tag=\"command\">commands</glossary>, you can refer to this <glossary tag=\"socket\">socket</glossary> with a socket identifier that looks like this:</p><p><i>host</i>:<i>port</i>[|<i>connectionID</i>]</p><p>where the <i>connectionID</i> is a number assigned by the <b>accept</b> <glossary tag=\"command\">command</glossary>. (You only need to specify the connection number if there is more than one <glossary tag=\"socket\">socket</glossary> connected to a particular <glossary tag=\"port\">port</glossary> and <glossary tag=\"disabled\">host</glossary>.)</p><p></p><p>The <i>callbackMessage</i> is sent to the <glossary tag=\"object\">object</glossary> whose <property tag=\"script\">script</property> contains the <b>accept</b> <glossary tag=\"command\">command</glossary>. Either one or two <glossary tag=\"parameter\">parameters</glossary> are sent with this <keyword tag=\"message box\">message</keyword>. The first <glossary tag=\"parameter\">parameter</glossary> is the <glossary tag=\"IP address\">IP address</glossary> of the system or <glossary tag=\"process\">process</glossary> making the connection. If a <glossary tag=\"datagram\">datagram</glossary> is being accepted, the second <glossary tag=\"parameter\">parameter</glossary> is the contents of the <glossary tag=\"datagram\">datagram</glossary>.</p><p></p><p>For technical information about sockets, see RFC 147 at <<u>http://www.ietf.org/rfc/rfc147.txt</u>>.</p><p>For technical information about UDP datagrams, see RFC 768 at <<u>http://www.ietf.org/rfc/rfc0768.txt</u>>.</p><p>For technical information about the numbers used to designate standard ports, see the list of port numbers at <<u>http://www.iana.org/assignments/port-numbers</u>><i>,</i> in particular the section entitled \"Well Known Port Numbers\".</p></description>"
      },
      "date": 1458310916025
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "356e2e1466f9ce98",
        "d7b7cdc2ae1feefc",
        "46d1298e8d335d82"
      ],
      "id": "46d1298e8d335d82",
      "date": 1458310933534
    },
    {
      "type": "edit",
      "id": "46d1298e8d335d82",
      "item": {
        "type": "paragraph",
        "id": "46d1298e8d335d82",
        "text": "Currently the dictionary files are in XML, which means they are rather opaquely swathed in tags. Some of these tags are meant to be rendered directly as HTML, while others are merely structural markings. Indeed, some of the older dictionary files contain extremely convoluted passages such as the following:"
      },
      "date": 1458310943050
    },
    {
      "type": "add",
      "id": "118e97c13345fc22",
      "item": {
        "type": "paragraph",
        "id": "118e97c13345fc22",
        "text": "…which can’t really be easily understood without, for example, displaying in a browser, or a field using the htmltext property. All of which makes it rather difficult to read and edit, and somewhat fragile too. So I spent some time recently thinking about how we could make dictionary files that are readable, extensible, and easy to adjust. Here is an example of the proposed format, again for the accept command:"
      },
      "after": "46d1298e8d335d82",
      "date": 1458310951722
    },
    {
      "type": "add",
      "id": "77515b49f8546c46",
      "item": {
        "type": "paragraph",
        "id": "77515b49f8546c46",
        "text": "Name: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0\n\nOS: mac,windows,linux\n\nPlatforms: desktop,server,web\n\nSecurity: network\n\nExample:\naccept connections on port 80 with message \"connectionMade\"\n\nExample:\naccept datagram connections on port 80 with message \"connectionMade\"\n\nExample:\non mouseUp\n   accept connections on port 80 with message \"connectionMade\"\nend mouseUp\n\non connectionMade pIPAddress\n   put \"Connection made:\" && pIPAddress\nend connectionMade\n\nParameters:\nnumber: \ncallbackMessage: The name of a message to be sent when a connection is made or a datagram is received.\nportNumber: The TCP port number on which to accept connections.\n\nDescription:\nUse the <accept> <command> when running a <server>, to accept <TCP> connections or <UDP> <datagram|datagrams> from other systems (or other <process|processes> on the same system).\nUse the datagram option if you want to accept UDP datagrams.\n\nWhen a connection is made or a datagram is received, the <accept> <command> creates a new <socket> that can be used to communicate with the other system (or <process>). When using the <close socket>, <read from socket>, or <write to socket> <command|commands>, you can refer to this <socket> with a socket identifier that looks like this:\nhost:port[|connectionID]\nwhere the connectionID is a number assigned by the <accept> <command>. (You only need to specify the connection number if there is more than one <socket> connected to a particular <port> and <host>.)\n\nThe <callbackMessage> is sent to the <object> whose <script> contains the <accept> <command>. Either one or two <parameter|parameters> are sent with this <message>. The first <parameter> is the <IP address> of the system or <process> making the connection. If a <datagram> is being accepted, the second <parameter> is the contents of the <datagram>.\n\nFor technical information about sockets, see RFC 147 at http://www.ietf.org/rfc/rfc147.txt.\nFor technical information about UDP datagrams, see RFC 768 at http://www.ietf.org/rfc/rfc0768.txt.\nFor technical information about the numbers used to designate standard ports, see the list of port numbers at http://www.iana.org/assignments/port-numbers, in particular the section entitled \"Well Known Port Numbers\".\n\nReferences: HTTPProxy (property), script (property), read from socket (command), write to socket (command), close socket (command), open socket (command), openSockets (function), hostAddressToName (function), hostName (function), hostAddress (function), peerAddress (function), hostNameToAddress (function), datagram (glossary), IP address (glossary), TCP (glossary), port (glossary), command (glossary), socket (glossary), UDP (glossary), host (glossary), server (glossary), message (glossary), parameter (glossary), process (glossary), object (object)\n\nTags: networking\nThere are really only two syntactic features of this docs format. The first is element specification, which is just done using a colon, e.g. Name: or Type:. The second is a general linking markup – enclosing text in < and >. Hopefully you’ll agree that the latter is much more legible, and editable to boot. Moreover, it points up an inconsistency in the original file, namely that there is a variable called ‘number’ specified by the syntax, but the associated parameter being described is ‘portNumber’. Converting the xml files into this new format has uncovered all of these inconsistencies.\n\nThe idea is that when we are building a new version of LiveCode, these docs files are parsed into an array which can be displayed by the dictionary in a CEF Browser object:\n\nAcceptEntry (1)"
      },
      "after": "118e97c13345fc22",
      "date": 1458310972982
    },
    {
      "type": "add",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image.\n\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\nMuch of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible.\n\nAnother important step we are taking is to include a table in every object’s dictionary entry, containing all of the messages and properties associated with that object. Here, for example is a snippet of how the image object’s new entry would look:\n\nImageEntry\n\nLet me know your thoughts in the comments."
      },
      "after": "77515b49f8546c46",
      "date": 1458310975155
    },
    {
      "item": {
        "type": "factory",
        "id": "dc604071efe243b0"
      },
      "id": "dc604071efe243b0",
      "type": "add",
      "after": "c2f8a2dbf3ed65f2",
      "date": 1458310986715
    },
    {
      "type": "remove",
      "id": "77515b49f8546c46",
      "date": 1458310988078
    },
    {
      "type": "edit",
      "id": "dc604071efe243b0",
      "item": {
        "type": "code",
        "id": "dc604071efe243b0",
        "text": "Name: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0\n\nOS: mac,windows,linux\n\nPlatforms: desktop,server,web\n\nSecurity: network\n\nExample:\naccept connections on port 80 with message \"connectionMade\"\n\nExample:\naccept datagram connections on port 80 with message \"connectionMade\"\n\nExample:\non mouseUp\n   accept connections on port 80 with message \"connectionMade\"\nend mouseUp\n\non connectionMade pIPAddress\n   put \"Connection made:\" && pIPAddress\nend connectionMade\n\nParameters:\nnumber: \ncallbackMessage: The name of a message to be sent when a connection is made or a datagram is received.\nportNumber: The TCP port number on which to accept connections.\n\nDescription:\nUse the <accept> <command> when running a <server>, to accept <TCP> connections or <UDP> <datagram|datagrams> from other systems (or other <process|processes> on the same system).\nUse the datagram option if you want to accept UDP datagrams.\n\nWhen a connection is made or a datagram is received, the <accept> <command> creates a new <socket> that can be used to communicate with the other system (or <process>). When using the <close socket>, <read from socket>, or <write to socket> <command|commands>, you can refer to this <socket> with a socket identifier that looks like this:\nhost:port[|connectionID]\nwhere the connectionID is a number assigned by the <accept> <command>. (You only need to specify the connection number if there is more than one <socket> connected to a particular <port> and <host>.)\n\nThe <callbackMessage> is sent to the <object> whose <script> contains the <accept> <command>. Either one or two <parameter|parameters> are sent with this <message>. The first <parameter> is the <IP address> of the system or <process> making the connection. If a <datagram> is being accepted, the second <parameter> is the contents of the <datagram>.\n\nFor technical information about sockets, see RFC 147 at http://www.ietf.org/rfc/rfc147.txt.\nFor technical information about UDP datagrams, see RFC 768 at http://www.ietf.org/rfc/rfc0768.txt.\nFor technical information about the numbers used to designate standard ports, see the list of port numbers at http://www.iana.org/assignments/port-numbers, in particular the section entitled \"Well Known Port Numbers\".\n\nReferences: HTTPProxy (property), script (property), read from socket (command), write to socket (command), close socket (command), open socket (command), openSockets (function), hostAddressToName (function), hostName (function), hostAddress (function), peerAddress (function), hostNameToAddress (function), datagram (glossary), IP address (glossary), TCP (glossary), port (glossary), command (glossary), socket (glossary), UDP (glossary), host (glossary), server (glossary), message (glossary), parameter (glossary), process (glossary), object (object)\n\nTags: networking\nThere are really only two syntactic features of this docs format. The first is element specification, which is just done using a colon, e.g. Name: or Type:. The second is a general linking markup – enclosing text in < and >. Hopefully you’ll agree that the latter is much more legible, and editable to boot. Moreover, it points up an inconsistency in the original file, namely that there is a variable called ‘number’ specified by the syntax, but the associated parameter being described is ‘portNumber’. Converting the xml files into this new format has uncovered all of these inconsistencies.\n\nThe idea is that when we are building a new version of LiveCode, these docs files are parsed into an array which can be displayed by the dictionary in a CEF Browser object:\n\nAcceptEntry (1)"
      },
      "date": 1458310989376
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "c2f8a2dbf3ed65f2",
        "dc604071efe243b0"
      ],
      "id": "d7b7cdc2ae1feefc",
      "date": 1458311021875
    },
    {
      "type": "edit",
      "id": "dc604071efe243b0",
      "item": {
        "type": "code",
        "id": "dc604071efe243b0",
        "text": "Name: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0\n\nOS: mac,windows,linux\n\nPlatforms: desktop,server,web\n\nSecurity: network\n\nExample:\naccept connections on port 80 with message \"connectionMade\""
      },
      "date": 1458311067104
    },
    {
      "type": "edit",
      "id": "dc604071efe243b0",
      "item": {
        "type": "code",
        "id": "dc604071efe243b0",
        "text": "Name: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0"
      },
      "date": 1458311075434
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "c2f8a2dbf3ed65f2"
      ],
      "id": "dc604071efe243b0",
      "date": 1458311082190
    },
    {
      "type": "edit",
      "id": "d7b7cdc2ae1feefc",
      "item": {
        "type": "code",
        "id": "d7b7cdc2ae1feefc",
        "text": "<description>Use the <b>accept</b> <glossary tag=\"command\">command</glossary> when running a <glossary tag=\"server\">server</glossary>, to accept <glossary tag=\"TCP\">TCP</glossary> connections or <glossary tag=\"UDP\">UDP</glossary> <glossary tag=\"datagram\">datagrams</glossary> from other systems (or other <glossary tag=\"process\">processes</glossary> on the same system).<p>Use the datagram option if you want to accept UDP datagrams.</p><p></p><p><b>Parameters:</b></p><p>The <i>portNumber</i> is the <glossary tag=\"TCP\">TCP</glossary> <glossary tag=\"port\">port</glossary> number on which to accept connections.</p><p>The <i>callbackMessage</i> is the name of a <keyword tag=\"message box\">message</keyword> to be sent when a connection is made or a <glossary tag=\"datagram\">datagram</glossary> is received.</p>...\n\n</description>"
      },
      "date": 1458311130479
    },
    {
      "type": "add",
      "item": {
        "url": "http://livecode.com/wp-content/uploads/2015/01/AcceptEntry-1.png",
        "text": "Transported image. [http://livecode.com/wp-content/uploads/2015/01/AcceptEntry-1.png source]",
        "type": "image",
        "id": "d319ed316b234700"
      },
      "after": "c2f8a2dbf3ed65f2",
      "id": "d319ed316b234700",
      "date": 1458311201886
    },
    {
      "type": "edit",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image.\n\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\nMuch of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible.\n\nAnother important step we are taking is to include a table in every object’s dictionary entry, containing all of the messages and properties associated with that object. Here, for example is a snippet of how the image object’s new entry would look:"
      },
      "date": 1458311212124
    },
    {
      "type": "add",
      "id": "4ce61c92cb74d537",
      "item": {
        "type": "paragraph",
        "id": "4ce61c92cb74d537",
        "text": "Let me know your thoughts in the comments."
      },
      "after": "c2f8a2dbf3ed65f2",
      "date": 1458311216804
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "c2f8a2dbf3ed65f2",
        "d319ed316b234700",
        "4ce61c92cb74d537"
      ],
      "id": "d319ed316b234700",
      "date": 1458311225019
    },
    {
      "type": "edit",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image.\n\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\nMuch of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible.\n\n"
      },
      "date": 1458311231629
    },
    {
      "type": "add",
      "id": "2bd874573c68b158",
      "item": {
        "type": "paragraph",
        "id": "2bd874573c68b158",
        "text": "Another important step we are taking is to include a table in every object’s dictionary entry, containing all of the messages and properties associated with that object. Here, for example is a snippet of how the image object’s new entry would look:"
      },
      "after": "c2f8a2dbf3ed65f2",
      "date": 1458311233756
    },
    {
      "type": "edit",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image.\n\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\n"
      },
      "date": 1458311239476
    },
    {
      "type": "add",
      "id": "93279d0744ea69a3",
      "item": {
        "type": "paragraph",
        "id": "93279d0744ea69a3",
        "text": "Much of this is in the early stages at the moment, so feedback is very welcome. If this or something like this does become the format of the dictionary files, we’ll immediately be seeking community help to improve our documentation. One of the primary objectives from my point of view would be to improve the examples. There are many examples in the dictionary which refer to not-necessarily-existant objects, or which rely on variables initialised outside of the example. It would be good if, as far as possible, the examples were self contained, and runnable; then they would hopefully be much more useful. I’d also like every parameter of the syntax to have as full a description as possible."
      },
      "after": "c2f8a2dbf3ed65f2",
      "date": 1458311239837
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "c2f8a2dbf3ed65f2",
        "d319ed316b234700",
        "93279d0744ea69a3",
        "2bd874573c68b158",
        "4ce61c92cb74d537"
      ],
      "id": "d319ed316b234700",
      "date": 1458311246558
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "c2f8a2dbf3ed65f2",
        "93279d0744ea69a3",
        "d319ed316b234700",
        "2bd874573c68b158",
        "4ce61c92cb74d537"
      ],
      "id": "d319ed316b234700",
      "date": 1458311252496
    },
    {
      "type": "edit",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode highlight.js build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image."
      },
      "date": 1458311265629
    },
    {
      "type": "add",
      "id": "55211a2f50497604",
      "item": {
        "type": "paragraph",
        "id": "55211a2f50497604",
        "text": "\nYou will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool.\n\n"
      },
      "after": "c2f8a2dbf3ed65f2",
      "date": 1458311266902
    },
    {
      "type": "edit",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode [[highlight.js]] build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image."
      },
      "date": 1458311280318
    },
    {
      "type": "edit",
      "id": "c2f8a2dbf3ed65f2",
      "item": {
        "type": "paragraph",
        "id": "c2f8a2dbf3ed65f2",
        "text": "I created a LiveCode [[highlight.js]] build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image - [https://github.com/livecode/livecode-ide/blob/develop/Documentation/html_viewer/js/highlight.pack.js github]"
      },
      "date": 1458311314240
    },
    {
      "type": "add",
      "id": "b0286bf1bcfbec0c",
      "item": {
        "type": "paragraph",
        "id": "b0286bf1bcfbec0c",
        "text": "For specific markup for elements of Livecode you may wish to take a look at [[Handler Documentation]]"
      },
      "after": "f6d260f777ac7595",
      "date": 1458318637489
    },
    {
      "type": "edit",
      "id": "46d1298e8d335d82",
      "item": {
        "type": "paragraph",
        "id": "46d1298e8d335d82",
        "text": "Currently the dictionary files are in XML, which means they are rather opaquely swathed in tags. Some of these tags are meant to be rendered directly as HTML, while others are merely structural markings - https://livecode.com/documentation-documentation-documentation/ fsad]"
      },
      "date": 1458390743050
    },
    {
      "type": "add",
      "id": "6cac0390107d687c",
      "item": {
        "type": "paragraph",
        "id": "6cac0390107d687c",
        "text": " Indeed, some of the older dictionary files contain extremely convoluted passages such as the following:"
      },
      "after": "46d1298e8d335d82",
      "date": 1458390744540
    },
    {
      "type": "edit",
      "id": "46d1298e8d335d82",
      "item": {
        "type": "paragraph",
        "id": "46d1298e8d335d82",
        "text": "Currently the dictionary files are in XML, which means they are rather opaquely swathed in tags. Some of these tags are meant to be rendered directly as HTML, while others are merely structural markings - [https://livecode.com/documentation-documentation-documentation/ livecode.com]"
      },
      "date": 1458390756737
    },
    {
      "type": "edit",
      "id": "d7b7cdc2ae1feefc",
      "item": {
        "type": "code",
        "id": "d7b7cdc2ae1feefc",
        "text": "<description>Use the <b>accept</b> <glossary tag=\"command\">command</glossary> when running a <glossary tag=\"server\">server</glossary>, to accept <glossary tag=\"TCP\">TCP</glossary> connections or <glossary tag=\"UDP\">...\n\n</description>"
      },
      "date": 1458390853608
    },
    {
      "type": "edit",
      "id": "dc604071efe243b0",
      "item": {
        "type": "code",
        "id": "dc604071efe243b0",
        "text": "Name: accept\nType: command\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \nSummary: Accepts an internet connection and creates a <socket> for that connection."
      },
      "date": 1458390877510
    },
    {
      "type": "edit",
      "id": "55211a2f50497604",
      "item": {
        "type": "paragraph",
        "id": "55211a2f50497604",
        "text": "You will also be able to document LiveCode script using exactly the same syntax, and autogenerate an API for it, if for example you are writing a library for distribution. The idea would be that you could add tabs in your dictionary viewer for each of the stacks that is currently being used as a library, as a handy reference tool."
      },
      "date": 1458390892780
    },
    {
      "item": {
        "type": "factory",
        "id": "e1c1b5a3b5327ec0"
      },
      "id": "e1c1b5a3b5327ec0",
      "type": "add",
      "after": "4ce61c92cb74d537",
      "date": 1458390899436
    },
    {
      "type": "edit",
      "id": "e1c1b5a3b5327ec0",
      "item": {
        "type": "code",
        "id": "e1c1b5a3b5327ec0",
        "text": "Name: accept\n\nType: command\n\nSyntax: accept [datagram] connections on port <number> with message <callbackMessage> \n\nSummary: Accepts an internet connection and creates a <socket> for that connection.\n\nIntroduced: 1.0\n\nOS: mac,windows,linux\n\nPlatforms: desktop,server,web\n\nSecurity: network\n\nExample:\naccept connections on port 80 with message \"connectionMade\"\n\nExample:\naccept datagram connections on port 80 with message \"connectionMade\"\n\nExample:\non mouseUp\n   accept connections on port 80 with message \"connectionMade\"\nend mouseUp\n\non connectionMade pIPAddress\n   put \"Connection made:\" && pIPAddress\nend connectionMade\n\nParameters:\nnumber: \ncallbackMessage: The name of a message to be sent when a connection is made or a datagram is received.\nportNumber: The TCP port number on which to accept connections.\n\nDescription:\nUse the <accept> <command> when running a <server>, to accept <TCP> connections or <UDP> <datagram|datagrams> from other systems (or other <process|processes> on the same system).\nUse the datagram option if you want to accept UDP datagrams.\n\nWhen a connection is made or a datagram is received, the <accept> <command> creates a new <socket> that can be used to communicate with the other system (or <process>). When using the <close socket>, <read from socket>, or <write to socket> <command|commands>, you can refer to this <socket> with a socket identifier that looks like this:\nhost:port[|connectionID]\nwhere the connectionID is a number assigned by the <accept> <command>. (You only need to specify the connection number if there is more than one <socket> connected to a particular <port> and <host>.)\n\nThe <callbackMessage> is sent to the <object> whose <script> contains the <accept> <command>. Either one or two <parameter|parameters> are sent with this <message>. The first <parameter> is the <IP address> of the system or <process> making the connection. If a <datagram> is being accepted, the second <parameter> is the contents of the <datagram>.\n\nFor technical information about sockets, see RFC 147 at http://www.ietf.org/rfc/rfc147.txt.\nFor technical information about UDP datagrams, see RFC 768 at http://www.ietf.org/rfc/rfc0768.txt.\nFor technical information about the numbers used to designate standard ports, see the list of port numbers at http://www.iana.org/assignments/port-numbers, in particular the section entitled \"Well Known Port Numbers\".\n\nReferences: HTTPProxy (property), script (property), read from socket (command), write to socket (command), close socket (command), open socket (command), openSockets (function), hostAddressToName (function), hostName (function), hostAddress (function), peerAddress (function), hostNameToAddress (function), datagram (glossary), IP address (glossary), TCP (glossary), port (glossary), command (glossary), socket (glossary), UDP (glossary), host (glossary), server (glossary), message (glossary), parameter (glossary), process (glossary), object (object)\n\nTags: networking"
      },
      "date": 1458390903432
    },
    {
      "item": {
        "type": "factory",
        "id": "73c15fd4357d3e51"
      },
      "id": "73c15fd4357d3e51",
      "type": "add",
      "after": "e1c1b5a3b5327ec0",
      "date": 1458390931348
    },
    {
      "type": "edit",
      "id": "73c15fd4357d3e51",
      "item": {
        "type": "code",
        "id": "73c15fd4357d3e51",
        "text": "Name:\nType:\nSyntax: \nIntroduced: \nOS: \nPlatforms: \nSecurity: \nExample:\nParameters:\nnumber: \ncallbackMessage: \nDescription:\nReferences: \nTags:"
      },
      "date": 1458391058733
    },
    {
      "type": "remove",
      "id": "73c15fd4357d3e51",
      "date": 1458391069555
    },
    {
      "item": {
        "type": "factory",
        "id": "b1988b3bea35ba91"
      },
      "id": "b1988b3bea35ba91",
      "type": "add",
      "after": "e1c1b5a3b5327ec0",
      "date": 1458391070903
    },
    {
      "type": "edit",
      "id": "b1988b3bea35ba91",
      "item": {
        "type": "markdown",
        "id": "b1988b3bea35ba91",
        "text": "* Name:\n* Type:\n* Syntax: \n* Introduced: \n* OS: \n* Platforms: \n* Security: \n* Example:\n* Parameters:\n* number: \n* callbackMessage: \n* Description:\n* References: \n* Tags:"
      },
      "date": 1458391107576
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "b0286bf1bcfbec0c",
        "b1988b3bea35ba91",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "6cac0390107d687c",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "c2f8a2dbf3ed65f2",
        "55211a2f50497604",
        "93279d0744ea69a3",
        "d319ed316b234700",
        "2bd874573c68b158",
        "4ce61c92cb74d537",
        "e1c1b5a3b5327ec0"
      ],
      "id": "b1988b3bea35ba91",
      "date": 1458391119385
    },
    {
      "type": "remove",
      "id": "c2f8a2dbf3ed65f2",
      "date": 1458391230281
    },
    {
      "item": {
        "type": "factory",
        "id": "db0c39f6ef40e6c4"
      },
      "id": "db0c39f6ef40e6c4",
      "type": "add",
      "after": "e1c1b5a3b5327ec0",
      "date": 1458391277679
    },
    {
      "type": "edit",
      "id": "db0c39f6ef40e6c4",
      "item": {
        "type": "reference",
        "id": "db0c39f6ef40e6c4",
        "site": "docs.livecode.world",
        "slug": "highlightjs",
        "title": "highlight.js",
        "text": "[[Ali Lloyd]] created a LiveCode [[highlight.js]] build, so that we could display LiveCode script in the colours familiar to you from the script editor. You can see the result of that in the code snippets in the above image - [https://github.com/livecode/livecode-ide/blob/develop/Documentation/html_viewer/js/highlight.pack.js github]"
      },
      "date": 1458391279794
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "b0286bf1bcfbec0c",
        "b1988b3bea35ba91",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "6cac0390107d687c",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "db0c39f6ef40e6c4",
        "55211a2f50497604",
        "93279d0744ea69a3",
        "d319ed316b234700",
        "2bd874573c68b158",
        "4ce61c92cb74d537",
        "e1c1b5a3b5327ec0"
      ],
      "id": "db0c39f6ef40e6c4",
      "date": 1458391288874
    },
    {
      "type": "remove",
      "id": "55211a2f50497604",
      "date": 1458391299408
    },
    {
      "type": "remove",
      "id": "b1988b3bea35ba91",
      "date": 1458392176975
    },
    {
      "type": "remove",
      "id": "e1c1b5a3b5327ec0",
      "date": 1458393047359
    },
    {
      "item": {
        "type": "factory",
        "id": "e1f758d698f32676"
      },
      "id": "e1f758d698f32676",
      "type": "add",
      "after": "4ce61c92cb74d537",
      "date": 1458393054388
    },
    {
      "type": "edit",
      "id": "e1f758d698f32676",
      "item": {
        "type": "reference",
        "id": "e1f758d698f32676",
        "site": "docs.livecode.world",
        "slug": "handler-documentation",
        "title": "Handler Documentation",
        "text": "Here is an example of how to document a Live Code [[Handler]]. See [[LiveCode Documentation Format Reference]] for further information."
      },
      "date": 1458393058052
    },
    {
      "type": "move",
      "order": [
        "deb2dfe89ff080ac",
        "f6d260f777ac7595",
        "b0286bf1bcfbec0c",
        "e1f758d698f32676",
        "356e2e1466f9ce98",
        "46d1298e8d335d82",
        "6cac0390107d687c",
        "d7b7cdc2ae1feefc",
        "118e97c13345fc22",
        "dc604071efe243b0",
        "db0c39f6ef40e6c4",
        "93279d0744ea69a3",
        "d319ed316b234700",
        "2bd874573c68b158",
        "4ce61c92cb74d537"
      ],
      "id": "e1f758d698f32676",
      "date": 1458393074188
    },
    {
      "type": "edit",
      "id": "f6d260f777ac7595",
      "item": {
        "type": "paragraph",
        "id": "f6d260f777ac7595",
        "text": "Here we provide a [[Create Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and free culture licensed -[http://creativecommons.org/licenses/by-sa/4.0/ creativecommons.org]"
      },
      "date": 1536147825077
    },
    {
      "type": "edit",
      "id": "f6d260f777ac7595",
      "item": {
        "type": "paragraph",
        "id": "f6d260f777ac7595",
        "text": "Here we provide a [[Create Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and [[free culture]] licensed -[http://creativecommons.org/licenses/by-sa/4.0/ creativecommons.org]"
      },
      "date": 1536147842286
    },
    {
      "type": "fork",
      "site": "docs.livecode.world",
      "date": 1536154468137
    },
    {
      "type": "edit",
      "id": "f6d260f777ac7595",
      "item": {
        "type": "paragraph",
        "id": "f6d260f777ac7595",
        "text": "Here we provide a [[Creative Commons]] licensed version of the Livecode Documentation, supplemented with content from [[Wikipedia and other sources]], together with articles sourced from the community and [[free culture]] licensed -[http://creativecommons.org/licenses/by-sa/4.0/ creativecommons.org]"
      },
      "date": 1536154648738
    }
  ]
}